{"version":3,"file":"static/js/765.a5d50c5d.chunk.js","mappings":"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","sources":["app/const.ts","common/utils/FileUtils.ts","workers/foreground/ImageLoader.ts","common/imgLib/Mask.ts","common/imgLib/Types.ts","common/imgLib/BoundingBox.ts","workers/background/LeafCrop.ts","app/urlParams.ts","common/imgLib/ImageBase.ts","workers/background/LeafSeg.ts","common/imgLib/ColourModels.ts","workers/background/LeafSegWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const root = \"/LeafSize/\";\nexport const settingsPath  = `${root}settings`;\nexport const selectionPath = `${root}`;\nexport const processingPath= `${root}process`;\nexport const resultPath    = `${root}result`;\nexport const imageSize     =1024;\nexport const dilation = 25;\nexport const minWidth = 256;\nexport const minHeight= 256;\nexport const GAUID    = \"G-2TD0F8G11B\";\n","const imageExtensions = ['.png', '.gif', '.jpeg', '.jpg'];\n\nexport default function isImage( name : string ) : boolean {\n  const lower = name.toLowerCase();\n  return imageExtensions.map( ext =>lower.endsWith(ext)).some((val)=>val)\n}\n\n// ðŸ– Node modules are no longer polyfilled in webpack 5. To enable that I should eject the solution.\n// since what I do here is very simple, I just implement it.\n// see https://stackoverflow.com/questions/64557638/how-to-polyfill-node-core-modules-in-webpack-5\nexport function noExtension( filename : string  ) : string {\n  const index = filename.lastIndexOf(\".\");\n  let res = filename;\n  if( index > 0 ){ // on purpose we skip position 0\n    res = filename.substring(0,index);\n  }\n  return res;\n}\n\nexport const  wait = async ( ms : number ) => new Promise(res=>setTimeout(res, ms))","import {noExtension} from '../../common/utils/FileUtils'\n\ntype Quadrant = 'Q0' | 'Q1' | 'Q2' | 'Q3' | 'All'\n\n// this interfce is designed to facilitate the testing (inversion of dependencies )\nexport interface ImgLoaderFileHandle {\n    name : string,\n    getFile : ()=>Promise<ImgLoaderFile>\n}\n\n\nexport interface ImgLoaderFile {\n    arrayBuffer : () => Promise<ArrayBuffer>\n}\n\ninterface ImageTile {\n    file :  ImgLoaderFileHandle //FileSystemHandle,\n    name : string,\n    quadrant : Quadrant\n}\n\nexport type ImageFileLoader =  ( handle : ImgLoaderFileHandle ) => Promise<ImageBitmap> \n\n/**\n * Image loader.\n * Load the images from file and split them up as necessary.\n */\nexport default class ImageLoader  {\n    private tiles : ImageTile[] = []\n    private cacheImage : ImageBitmap | null = null;\n    private cacheFile  : ImgLoaderFileHandle | null = null;\n    private getImageFromFile : ImageFileLoader\n    private targetSize : number;\n\n    /**\n     * construct a ImageLoader object\n     * @param files list of files to load\n     * @param numDishes  number of dishes per image : 1 or 4\n     * @param targetSize  target size for the image's diagonal.\n     * @param imageFileLoader loader function (if required)\n     */\n    constructor ( files : ImgLoaderFileHandle[] | null , numDishes : number, targetSize : number, imageFileLoader : ImageFileLoader = getImageFromFile ){\n        this.tiles = []\n        this.getImageFromFile = imageFileLoader;\n        this.targetSize = targetSize;\n        if (numDishes !==1 && numDishes !== 4 ) throw new Error(`not supported num Dishes ${numDishes}`)\n\n        if( files ){\n            switch(numDishes){\n                case 1: {\n                    this.tiles = files.map(file => ({ file, quadrant : 'All', name : noExtension(file.name)}))\n                    break;\n                }\n                case 4: {\n                    files.forEach(file =>{\n                        ['Q0','Q1','Q2','Q3'].forEach(quadrant=>{\n                            this.tiles.push({\n                                file,\n                                name : noExtension(file.name)+'-'+quadrant,\n                                quadrant : quadrant as Quadrant\n                            })\n                        })\n                    })\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * list of images generated\n     */\n    get List() : string [] {\n        return this.tiles.map(f=>f.name);\n    }\n\n    /**\n     * get file handle given the image name\n     */\n    FileHandle( name : string ) :ImgLoaderFileHandle | undefined {\n        return this.tiles.find(v=>v.name===name)?.file;\n    }\n\n    /**\n     * number of dishes for image\n     */\n    get NumDishes() : number {\n        let qList = new Set(this.tiles.map(v=>v.quadrant));\n        return qList.size;\n    }\n\n    /**\n     * Extract an image from the file.\n     * @param inCanvas canvas where the image will be copied to.\n     * @param index index of the image to extract\n     * @returns scale : downsample value of the original image in order to reach the diagonal size set in the constructor. imageData : image Data for the canvas object\n     */\n    async getImage( index : number ): Promise< { scale : number, imgData : ImageData|null }> {\n        let scale = 0;\n        let imgData = null;\n        if( !this.tiles || !this.tiles.length ) return {scale, imgData }; // this can happen as transition\n        if( index <0 || index >this.tiles.length) throw Error(`undexpected index : requested ${index} but got ${this.tiles.length}`)\n        const tile = this.tiles[index];\n        const img = await this.getImageFromCache( tile );\n        const imgWidth = img.width;\n        const imgHeight= img.height;\n        let xTopLft = 0;\n        let yTopLft = 0;\n        let xBtmRgt = imgWidth;\n        let yBtmRgt = imgHeight;\n        const xMid = imgWidth/2 | 0;\n        const yMid = imgHeight/2 | 0;\n        switch( tile.quadrant ){\n            case 'Q0' : {\n                xTopLft = 0;\n                yTopLft = 0;                \n                xBtmRgt = xMid;\n                yBtmRgt = yMid;\n                break;\n            }\n            case 'Q1' : {\n                xTopLft = xMid;\n                yTopLft = 0;\n                xBtmRgt = imgWidth;\n                yBtmRgt = yMid;\n                break;\n            }\n            case 'Q2' : {\n                xTopLft = 0;\n                yTopLft = yMid;                \n                xBtmRgt = xMid;\n                yBtmRgt = imgHeight;\n                break;\n            }\n            case 'Q3' : {\n                xTopLft = xMid;\n                yTopLft = yMid;                \n                xBtmRgt = imgWidth;\n                yBtmRgt = imgHeight;\n                break;\n            }\n        }\n        const srcWidth = xBtmRgt-xTopLft;\n        const srcHeight= yBtmRgt-yTopLft;\n        const srcDiag = Math.sqrt(srcHeight*srcHeight+srcWidth*srcWidth);\n        scale = Math.min( 1, this.targetSize/srcDiag);\n        const dstWidth = srcWidth * scale;\n        const dstHeight= srcHeight * scale;\n\n        // we need to get to the pixel data, and so we need a canvas (unfortunately)\n        // see https://github.com/whatwg/html/issues/4785\n        // Note OffscreenCanvas is deprecated below because it is experimental \n        // see https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas/OffscreenCanvas \n        // however since this will run in the workers I have no othre option.\n        let canvas : HTMLCanvasElement | OffscreenCanvas;\n        if( typeof document === 'undefined' ) {\n            // worker\n            canvas = new OffscreenCanvas(dstWidth, dstHeight);\n        } else {\n            // window\n            canvas = document.createElement('canvas')\n            canvas.width = dstWidth;\n            canvas.height= dstHeight;\n        }\n\n        // Extract the pixel data which is needed for further processing.\n        const ctx = canvas.getContext('2d');\n        if( ctx ) { \n            ctx.drawImage( img, xTopLft, yTopLft, srcWidth, srcHeight, 0, 0, dstWidth, dstHeight);\n            imgData = ctx.getImageData(0,0,dstWidth, dstHeight);\n            // Debug only\n            // ctx.font = '48px serif'; // debug only.\n            // ctx.fillText(tile.name, 10, 60);\n        }\n        return { scale, imgData }\n    }\n\n    /**\n     * This function perform some simple caching on the images because when the user is settings 4 dishes per image,\n     * we can effectively load the same image for 4 different request.\n     * @param tile tile which describes the images to extract.\n     * @returns \n     */\n    private async getImageFromCache( tile : ImageTile  ) : Promise<ImageBitmap> {\n        if( this.cacheFile !== tile.file  ){\n            if( this.cacheImage ) this.cacheImage.close(); // free resources.\n            this.cacheImage = await this.getImageFromFile( tile.file );\n            this.cacheFile  = tile.file;\n        } \n        return this.cacheImage!;\n    }\n}\n\n    /**\n     * Load the image from file.\n     * @param handle file to load\n     * @returns \n     */\n     async function getImageFromFile( handle : ImgLoaderFileHandle ) : Promise<ImageBitmap> {\n        const file = await handle.getFile();\n        const data = await file.arrayBuffer();\n        const blob = new Blob([data]);\n        return createImageBitmap(blob);\n    }","import BoundingBox from './BoundingBox';\nimport IImage, {Bbox, Colour, Point} from './Types'\n\nexport function isMask( obj : any ) : obj is Mask {\n    return obj.constructor.name === \"Mask\"\n}\n\n\n/**\n * 2D binary mask\n */\nexport default class Mask implements IImage<boolean> {\n    private pixels : boolean [];\n    private w : number ;\n\n    /**\n     * Initialize an empty mask, with all values to false.\n     * @param width  \n     * @param height \n     */\n    constructor( width : number, height : number ){\n        this.w = width;\n        this.pixels= new Array<boolean>(width*height).fill(false);\n    }\n\n    /**\n     * clone the incoming mask\n     * @param srcMask \n     */\n    static Clone( srcMask : Mask ) : Mask {\n        const mask  = new Mask(srcMask.width, srcMask.height);\n        mask.pixels = [...srcMask.pixels];\n        return mask;\n    }\n\n    /**\n     * get the unidimensional pixel array, row major\n     */\n    get imagePixels() : boolean [] {\n        return this.pixels;\n    }\n\n    /**\n     * image width\n     */\n    get width() : number {\n        return this.w;\n    }\n\n    /**\n     * image height\n     */\n    get height():number {\n        return this.pixels.length/this.w;\n    }\n\n    /**\n     * area (number of pixels set to true)\n     */\n    get area() : number {\n        return this.pixels.reduce((s,v)=>s+(v?1:0), 0)\n    }\n\n    /**\n     * get a value in the mask\n     * @param x \n     * @param y \n     * @returns \n     */\n    get( x: number, y: number ){\n        this.checkSize(x,y);\n        return this.pixels[this.w*y+x];\n    }\n\n    /**\n     * Set a value in the mask\n     * @param x \n     * @param y \n     * @param v value\n     */\n    set( x: number, y:number, v: boolean ){\n        this.checkSize(x,y);\n        this.pixels[this.w*y+x]=v;\n    }\n\n    /*\n    * overwrite toString in order to provide information when the image is printed\n    */\n    toString() : string {\n        return `Mask ${this.width}x${this.height}`\n        }\n\n    /**\n     * And the mask with the incoming mask in place.\n     * @param srcMask \n     */\n    And( srcMask : Mask ) {\n        if( srcMask.pixels.length !== this.pixels.length ) throw new Error(`Wrong Mask sizes : ${srcMask.pixels.length} vs ${this.pixels.length}`);\n        this.pixels = this.pixels.map((v,i)=>v&&srcMask.pixels[i]);\n    }\n\n\n    /**\n     * Or the mask with the incoming mask in place\n     * @param srcMask \n     */\n    Or( srcMask : Mask ) {\n        if( srcMask.pixels.length !== this.pixels.length ) throw new Error(`Wrong Mask sizes : ${srcMask.pixels.length} vs ${this.pixels.length}`);\n        this.pixels = this.pixels.map((v,i)=>v||srcMask.pixels[i]);\n    }\n\n    /**\n     * subtract the incoming mask, in place.\n     * @param srcMask \n     */\n    Minus( srcMask : Mask ) {\n        if( srcMask.pixels.length !== this.pixels.length ) throw new Error(`Wrong Mask sizes : ${srcMask.pixels.length} vs ${this.pixels.length}`);\n        srcMask.pixels.forEach((v,i)=> v ? this.pixels[i]=false : null); // in place, otherwise the fill function will take too long.\n    }\n\n    /**\n     * Not the mask in place.\n     */\n    Not() {\n        this.pixels = this.pixels.map((v)=>!v); \n    }\n\n    /**\n     * invoke for every pixel in the image the function provided.\n     * @param func \n     */\n    foreachPixel (func : (x:number, y:number, v: boolean )=> void) : void  {\n        this.pixels.forEach((val, i)=>{\n            const x = i % this.w;\n            const y = i / this.w|0;\n            func(x,y,val);\n        })\n    }\n\n    /**\n     * if the mask has dimension 0.\n     */\n    get IsEmpty() : boolean {\n        return !this.w || !this.pixels.length;\n    }\n\n    /**\n     * Fill operation : retun a mask with the connected compnent (9 neighbourd) to the seed point.\n     * @param xSeed x coordinate seed point. It shall be inside the image\n     * @param ySeed y coordinate seed point. It shall be inside the image.\n     * @returns \n     */\n\n    Fill(xSeed : number, ySeed : number ) : Mask {\n        const width = this.width;\n        const height= this.height;\n        if( xSeed <0 || xSeed >= width || ySeed <0 || ySeed >=height  ) throw new Error(`invalid seed point ${xSeed},${ySeed}`);\n        const inpPixels = this.pixels;\n        const outMask   = new Mask(width,height);\n        const outPixels = outMask.imagePixels;\n        const NeigbourdPoints : Point [] = [ { x:-1, y:0 },\n                                             { x:1, y:0 },\n                                             { x:0, y:1 },\n                                             { x:0, y:-1 },\n                                             { x:1, y:1 },\n                                             { x:-1, y:1 },\n                                             { x:1, y:-1 },\n                                             { x:-1, y:-1 }\n        ]\n\n        const stack : Point[] = [ {x:xSeed, y:ySeed}]\n        outPixels[ySeed*width+xSeed] = true;\n\n        while( stack.length > 0 ){\n\n            const pt = stack.shift()!\n\n            for( const p of NeigbourdPoints ){\n                const x = pt.x + p.x;\n                const y = pt.y + p.y;\n                if( x>=0 && x<width && y>=0 && y<height ){\n                    const offset = y*width+x;\n                    if( inpPixels[offset] && !outPixels[offset] ){\n                        outPixels[offset]= true;\n                        stack.push({x,y})\n                    }\n                }\n            }\n        }\n\n        return outMask;\n    }\n\n    /**\n     * applies a dilation with a squared mask, 2*halfSize+1 x 2*halfSize+1\n     * @param halfSize mask half size\n     * @returns \n     */\n    Dilate(halfSize:number ) : Mask {\n        if ( this.IsEmpty ) return new Mask(0,0);\n        const width = this.width;\n        const height= this.height;\n        const inpPixels = this.pixels;\n        const outMask   = Mask.Clone(this);\n        const outPixels = outMask.imagePixels;\n\n        outMask.foreachPixel((x,y,v)=>{\n            if( !v && x>=halfSize && x<width-halfSize && y>=halfSize && y<height-halfSize  ){\n                let val = false;\n                const len = 2*halfSize+1;\n                for( let yk = y-halfSize; yk<=y+halfSize; yk++ ){\n                    let offset  = yk * width+x-halfSize;\n                    for( let off=offset; off<len+offset; off++) {\n                        val ||= inpPixels[off];\n                    }\n                    if( val ) break;\n                }\n                outPixels[y*width+x]= val;\n            }\n        })\n\n        return outMask;\n    }\n\n    /**\n     * overlays the current mask on the image provided.\n     * @param imgData \n     * @param color  \n     */\n    Overlay(imgData : ImageData, {r,g,b,a =255 } : Colour, offset? : Point) : void {\n        if( !offset && ( this.width !== imgData.width || this.height !== imgData.height) ) throw new Error(`Invalid data : Mask size ${this.width}x${this.height} and image data ${imgData.width}x${imgData.height}`)\n        if( offset ) {\n            if( offset.x < 0 || offset.y < 0 ) throw new Error (`negative offset not supported : ${offset.x},${offset.y}`);\n            if( offset.x+this.width > imgData.width || offset.y+this.height> imgData.height ) throw new Error(`Invalid offset : mask shall be completly inside the image ${offset.x+this.width}x${offset.y+this.height} and image ${imgData.width}x${imgData.height}`)\n        }\n        const xOffset = offset ? offset.x : 0;\n        const yOffset = offset ? offset.y : 0;\n        const data = imgData.data;\n        let ptr = ( yOffset * imgData.width+xOffset) * 4;\n        const alpha = a/255;\n        r *= alpha;\n        b *= alpha;\n        g *= alpha;\n        const weight = 1-alpha;\n        const imgStride = imgData.width * 4;\n        const maskLast  = ( xOffset + this.width ) * 4;\n        const incr      = ( imgData.width - this.width ) * 4;\n\n        this.pixels.forEach((v)=>{\n            if( v ){\n                let p = ptr;\n                const red  = data[ptr++] * weight + r;\n                const green= data[ptr++] * weight + g;\n                const blue = data[ptr++] * weight + b;\n                const alpha= data[ptr++] * weight + a;\n                data[p++] = red;\n                data[p++] = green;\n                data[p++] = blue;\n                data[p++] = alpha;\n            } else {\n                ptr += 4;\n            } \n            if( ptr % imgStride === maskLast ) ptr += incr;\n        })\n    }\n\n    /**\n     * return the num largest component of the mask.\n     * @param num number of components to return.\n     * @returns list of connected component, sorted by size.\n     */\n    Components ( num : number ) : Mask [] {\n        const list : {mask:Mask, area:number }[] = [];\n\n        this.foreachPixel((x,y,v)=>{\n            if( v ){\n                const mask = this.Fill(x,y);\n                const area = mask.area;\n                list.push({mask,area});\n                list.sort((a,b)=>b.area-a.area);\n                list.length = Math.min(list.length,num); // trucate the list as necessary.\n                this.Minus(mask);\n            }\n        })\n\n        return list.map(v=>v.mask);\n    }\n\n    /**\n     * dermine the boundaies of the bask\n     */\n    Boundaries() :  Bbox {\n        let xMin = this.width;\n        let yMin = this.height;\n        let xMax = 0;\n        let yMax  =0;\n\n        this.foreachPixel((x,y,v)=>{\n            if( v ){\n                xMin = x < xMin ? x : xMin;\n                yMin = y < yMin ? y : yMin;\n                xMax = x > xMax ? x : xMax;\n                yMax = y > yMax ? y : yMax;\n            }\n        })\n\n        return BoundingBox.FromValues(xMin, yMin, xMax+1, yMax+1);\n    }\n\n    private checkSize( x : number, y: number ){\n        if( x < 0 || x > this.w || y <0 || y > this.height ) throw new Error(`Wrong coordinate for mask (${x},${y}) and mask size ${this.w}x${this.height}`);\n    }\n\n}","\n/**\n * definition of a colour. Each channel is considered an 8 bit integer.\n * the values are *not* pre multiplied by alpha. If alpha is not present \n * it is considered 255, and so the colour is fully opaque.\n */\nexport interface Colour {\n    r : number,\n    g : number,\n    b : number,\n    a?: number\n}\n\n/**\n * 2D point. Defined here because DOMPoint requires many more parameters\n * which are not necessary for the imgLib purposes.\n */\nexport interface Point {\n    x: number,\n    y: number\n}\n\n\n/**\n * defines a bondung box.\n */\nexport interface Bbox {\n    ulc : Point,\n    size: {\n        width : number,\n        height: number\n    }\n}\n\n/**\n * generic interface for an image/mask object. Something which can be displayed and/or overlayed on an image.\n */\nexport default interface IImage<T> {\n    readonly width : number,\n    readonly height: number,\n    set : (x:number, y:number, v : T )=> void,\n    get : (x:number, y:number) => T,\n    foreachPixel : (func:(x:number, y:number, v:T)=>void)=>void\n}\n\n/* unfortunately this is necesary in order to deal with the jest dom, which doesn't support the\n * ImageData object and the browser dom.\n */\n\nexport type ImageDataAllocator = ( data : Uint8ClampedArray, width : number, height : number ) => ImageData;\n\nexport const imageDataAllocator = ( data : Uint8ClampedArray, width : number, height : number ) : ImageData =>{\n    return new ImageData(data, width, height);\n}","import Mask from \"./Mask\";\nimport { Bbox, Point } from \"./Types\";\nimport { ImageDataAllocator, imageDataAllocator } from \"./Types\";\n\n/**\n * simple class to manipulate bounding boxes.\n */\nexport default class BoundingBox  {\n\n    static allocator = imageDataAllocator;\n\n    private constructor () { }  // singleton\n\n    /**\n     * Set the allocator for this class. Use for testing.\n     * @param imageDataAllocator functon which instiate the canvas's imagedata\n     */\n    static SetImageDataAllocator( imageDataAllocator  : ImageDataAllocator  ) : void {\n        BoundingBox.allocator=imageDataAllocator\n    }\n\n    static FromPoints( pt1 : Point, pt2 : Point ){\n        return BoundingBox.FromValues(pt1.x, pt1.y, pt2.x, pt2.y);\n    }\n\n    /**\n     * generates a boundin box from point\n     * @param x1  x point 1\n     * @param y1  y point 1\n     * @param x2  x point 2\n     * @param y2  y point 2\n     * @returns \n     */\n    static FromValues( x1 : number, y1 : number, x2 : number, y2 : number ) : Bbox {\n        const xmin = Math.min(x1, x2);\n        const xmax = Math.max(x1, x2);\n        const ymin = Math.min(y1, y2);\n        const ymax = Math.max(y1, y2);\n        return {\n            ulc : {\n                x: xmin,\n                y: ymin\n            },\n            size : {\n                width : xmax-xmin,\n                height: ymax-ymin\n            }\n        }\n    }\n\n    /**\n     * Bounding box of the image.\n     * @param imageData \n     * @returns \n     */\n    static FromImage(imageData : {width:number, height:number }) : Bbox {\n        return {\n            ulc : { x:0, y:0 },\n            size: { width:imageData.width, height:imageData.height}\n        }\n    }\n    \n    static get Empty() : Bbox {\n        return {\n            ulc : {x:0, y:0},\n            size: {width:0, height:0}\n        }\n    }\n\n    static IsEmpty(bbox:Bbox) : boolean {\n        return bbox.size.width <=0 || bbox.size.height <= 0;\n    }\n\n    /**\n     * Merge (union) a list of bounding boxes\n     * @param boxes list of bounding boxes\n     * @returns \n     */\n    static Merge( boxes : Bbox[] ) : Bbox {\n        let box =  BoundingBox.Empty;\n        if( boxes.length > 0 ){\n            let xmin = boxes[0].ulc.x;\n            let ymin = boxes[0].ulc.y;\n            let xmax = xmin;\n            let ymax = ymin;\n            boxes.forEach(b=>{\n                xmin = Math.min(b.ulc.x, xmin);\n                ymin = Math.min(b.ulc.y, ymin);\n                xmax = Math.max(b.ulc.x+b.size.width, xmax);\n                ymax = Math.max(b.ulc.y+b.size.height, ymax);\n            })\n            box = BoundingBox.FromValues(xmin, ymin, xmax, ymax);\n        }\n        return box;\n    }\n\n    static Dilate(bbox:Bbox, dx : number, dy: number ): Bbox{\n        return {\n            ulc : { x: bbox.ulc.x-dx, y:bbox.ulc.y-dy},\n            size: { width : bbox.size.width+2*dx, height : bbox.size.height+2*dy}\n        }\n    }\n\n    /**\n     * Intersect a list of bounding boxes.\n     * @param boxes list of bouind boxes to intersect.\n     * @returns \n     */\n    static Intersect(boxes : Bbox[] ) : Bbox {\n        let box =  BoundingBox.Empty;\n        if( boxes.length > 0 ){\n            let xmin = boxes[0].ulc.x;\n            let ymin = boxes[0].ulc.y;\n            let xmax = xmin+boxes[0].size.width;\n            let ymax = ymin+boxes[0].size.height;\n            boxes.forEach(b=>{\n                xmin = Math.max(b.ulc.x, xmin);\n                ymin = Math.max(b.ulc.y, ymin);\n                xmax = Math.min(b.ulc.x+b.size.width, xmax);\n                ymax = Math.min(b.ulc.y+b.size.height, ymax);\n            })\n            box = {\n                ulc: {x:xmin, y:ymin},\n                size:{width:xmax-xmin, height:ymax-ymin}\n            }\n        }\n        return box;\n    }\n\n    /**\n     * \n     * @param bbox bouding box\n     * @param imageData  image data to crop\n     * @returns cropped image.\n     */\n    static CropImage(bbox : Bbox, imageData : ImageData ) : ImageData  {\n        const imageBox = BoundingBox.FromImage(imageData)\n        const int = BoundingBox.Intersect([bbox, imageBox]);\n        const width = Math.max(int.size.width,0)\n        const height= Math.max(int.size.height,0)\n        const dst = new Uint8ClampedArray(width*height*4);\n        let res : ImageData = BoundingBox.allocator(dst, width, height);\n\n        if( width * height > 0 ){\n            const src = imageData.data;\n            let dstPt = 0;\n\n            for( let y=int.ulc.y; y<int.ulc.y+height; y++){\n                let srcPt= ( y* imageData.width+ bbox.ulc.x ) * 4;\n                for( let x=0; x<width; x++ ){\n                    dst[dstPt++] = src[srcPt++];\n                    dst[dstPt++] = src[srcPt++];\n                    dst[dstPt++] = src[srcPt++];\n                    dst[dstPt++] = src[srcPt++];\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * crop the input mask on the bouding box provided.\n     * @param bbox \n     * @param inpMask \n     * @returns \n     */\n    static CropMask(bbox : Bbox, inpMask : Mask ) : Mask {\n        const imageBox = BoundingBox.FromImage(inpMask);\n        const int = BoundingBox.Intersect([bbox, imageBox]);\n        const width = Math.max(int.size.width,0)\n        const height= Math.max(int.size.height,0)\n        const outMask = new Mask(width, height);\n        if( width * height >0 ){\n            const inpWidth = inpMask.width;\n            const inpPixels= inpMask.imagePixels;\n            const outPixels = outMask.imagePixels;\n            let outPtr = 0;\n            for( let y=int.ulc.y; y<int.ulc.y+int.size.height; y++ ){\n                let inPtr = y * inpWidth + int.ulc.x;\n                let inEnd = inPtr+int.size.width;\n                while(inPtr<inEnd) outPixels[outPtr++]=inpPixels[inPtr++];\n            }\n        }\n        return outMask;\n    }\n\n}","import { dilation, minHeight, minWidth } from \"../../app/const\";\nimport BoundingBox from \"../../common/imgLib/BoundingBox\";\nimport { Bbox } from \"../../common/imgLib/Types\";\nimport { LeafArea } from \"../../pages/process/ProcessSlice\";\n\n/**\n * simple class to crop the image based on the bounding box\n */\nexport default class LeafCrop {\n    private constructor() {} // singleton\n\n    static Process( areas : LeafArea [], bboxs : Bbox[], imgData : ImageData, scale : number ) {\n        const box = BoundingBox.Merge(bboxs);\n        let leafData  : ImageData = imgData;\n        let leafAreas : LeafArea [] = [];\n        const rescale = 1/(scale*scale);\n        if( !BoundingBox.IsEmpty(box) ){\n            let wDilation = dilation;\n            let hDilation = dilation;\n            if( box.size.width < minWidth ) wDilation = Math.max(wDilation, ( minWidth-box.size.width)/2|0);\n            if( box.size.height< minHeight) hDilation = Math.max(hDilation, ( minHeight-box.size.height)/2|0);\n            const dBox = BoundingBox.Dilate(box, wDilation, hDilation);\n            leafData = BoundingBox.CropImage(dBox, imgData)!;\n            leafAreas= areas.map(aInfo=> ({\n                leaf:aInfo.leaf*rescale|0, \n                path:aInfo.path*rescale|0\n            }) );\n        }\n        return {\n            imgData : leafData,\n            areas : leafAreas\n        };\n    }\n}","\n/**\n * Simple class which centralize the access to the URL parameters for the application\n */\nexport default class URLParams {\n\n    private static params = new URLSearchParams( typeof window === 'undefined' ? '' : window.location.search );\n    private constructor() { } // singleton\n\n    /**\n     * for web web wrokers\n     * @param params \n     */\n    static SetSearchParam( urlParams: string ){\n        URLParams.params = new URLSearchParams(urlParams); \n    }\n\n    /**\n     * return the pack mode for the pathogen segmentation\n     */\n    static get PackMode () : string  {\n        return URLParams.params.get('PackMode') ?? \"Lab\";\n    }\n\n}","import IImage from \"./Types\";\n\ninterface TypedArray {\n    readonly length : number;\n    [n: number]: number;\n    buffer : ArrayBuffer;\n    reduce ( func : (total : number, currentValue : number, index : number ) => number, initialvalue : number) : number;\n}\n\ninterface TypedArrayConstructor<T extends TypedArray> {\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): T;\n}\n\nexport type ImageUint8  = ImageBase<Uint8Array,Uint8ArrayConstructor>\nexport type ImageUint16 = ImageBase<Uint16Array,Uint16ArrayConstructor>\nexport type ImageFloat32= ImageBase<Float32Array,Float32ArrayConstructor>\n\n// this is the generic Image type. Using this approach we avoid to expose\n// the complexity of the generic used below.\n\nexport type Image2D = ImageUint8 | ImageUint16 | ImageFloat32\nexport type ImagePixels = Uint8Array | Uint16Array | Float32Array\nexport type ImageType = 'Uint8' | 'Uint16' | 'Float32'\n\n\nexport function isImage( obj : any ) : obj is Image2D {\n    return obj.constructor.name === \"ImageBase\"\n}\n\nexport class ImageFactory {\n\n    static Uint8( width : number, height : number ) : ImageUint8 {\n        return new ImageBase<Uint8Array,Uint8ArrayConstructor>(Uint8Array.BYTES_PER_ELEMENT, Uint8Array, width, height)\n    }\n    static Uint16( width : number, height : number ) : ImageUint16{\n        return (new ImageBase<Uint16Array,Uint16ArrayConstructor>(Uint16Array.BYTES_PER_ELEMENT, Uint16Array, width, height)) \n    }\n    static Float32( width : number, height : number ): ImageFloat32{\n        return new ImageBase<Float32Array,Float32ArrayConstructor>(Float32Array.BYTES_PER_ELEMENT, Float32Array, width, height)\n    }\n    static Image(type : ImageType, width : number, height : number ) : Image2D {\n        switch( type ){\n            case 'Uint8':\n                return ImageFactory.Uint8(width,height)\n            case 'Uint16':\n                return ImageFactory.Uint16(width,height)\n            case 'Float32':\n                return ImageFactory.Float32(width,height)\n        }\n    }\n}\n\n\nclass ImageBase<T extends TypedArray, C extends TypedArrayConstructor<T>>  implements IImage<number> {\n\n    private buffer : T\n    private pixels : T [] \n\n    constructor( elementSize : number, constructor : C, width : number, height : number ) {\n        let nPixels= width * height;\n        let bytes  = nPixels * elementSize\n        let buffer= new ArrayBuffer(bytes);\n        this.pixels= Array.from(Array(height), (e,i)=> new constructor (buffer, width*elementSize*i, width) ) \n        this.buffer= new constructor(buffer, 0, nPixels)\n    }\n\n\n    /**\n     * get type of pixel stored.\n     */\n    get imageType(): ImageType {\n        return this.pixels[0].constructor.name.replace('Array','') as ImageType\n    }\n\n    /**\n     * returns the current list of pixels.\n     */\n    get imagePixels(): T {\n        return this.buffer \n    }\n\n    /**\n     *  get the image buffer\n     */\n    get imageBuffer() : ArrayBuffer {\n        return this.buffer.buffer\n    }\n\n    /**\n     * get image height\n     */\n    get height() : number {\n        return this.pixels.length\n    }\n\n    /**\n     * return image height\n     */\n    get width() : number {\n        return this.pixels[0].length\n    }\n\n    /*\n    * overwrite toString in order to provide information when the image is printed\n    */\n    toString() : string {\n       return `image ${this.imageType} ${this.width}x${this.height}`\n    }\n\n    /**\n     * get a pixel value.\n     * @param x row of the pixel queried\n     * @param y column of the pixel queried\n     */\n    get( x: number, y: number ) : number {\n        if( !this.checkBoundary(x,y)) throw new Error (`Invalid image coordinates queried: image size ${this.width}x${this.height} pixel ${x},${y}`)\n        return this.pixels[y][x]\n    }\n\n    /**\n     * loop thought all the pixel in the image\n     * @param func function to process each pixel in the image\n     */\n    foreachPixel (func : (x:number, y:number, v: number )=> void) : void  {\n        this.pixels.forEach((val, y)=>{ for(let x=0; x<val.length;x++) func(x,y,val[x])})\n    }\n\n    /**\n     * max pixel value in the image\n     */\n    maxValue() : number {\n        return this.buffer.reduce((max, val, idx)=>Math.max(val,max),this.buffer[0])\n    }\n\n    /**\n     * min pixel value in the image\n     */\n    minValue() : number {\n        return this.buffer.reduce((min, val, idx)=>Math.min(val,min),this.buffer[0])\n    }\n\n    /**\n     * get a row of pixels\n     * @param y row of pixels to select.\n     */\n    getRow(y:number) : T {\n        if( y<0 || y>this.height )throw new Error (`Invalid y coordinate queried : image height ${this.height} y ${y}`)\n        return this.pixels[y]\n    }\n\n    /**\n     * \n     * @param x row pixel to set\n     * @param y column pixel to se\n     * @param value  value to set\n     */\n    set(x:number, y:number, value : number) : void {\n        if( !this.checkBoundary(x,y)) throw new Error (`Invalid image coordinates set: image size ${this.width}x${this.height} pixel ${x},${y}`)\n        this.pixels[y][x]= value\n    }\n\n    /**\n     * convert and copy this image in a new image 8bit\n     * @param slope multiplication factor applied to every pixel in the conversion\n     * @param intercept intercept used for every pixel in the conversion\n     */\n    convertTo8Uint( slope? : number, intercept? : number) : ImageUint8 {\n        return this.convertTo<ImageUint8>('Uint8', slope, intercept);\n    }\n\n    /**\n     * convert and copy this image in a new image 16bits\n     * @param slope multiplication factor applied to every pixel in the conversion\n     * @param intercept intercept used for every pixel in the conversion\n     */\n    convertTo16Uint( slope? : number, intercept? : number) : ImageUint16 {\n        return this.convertTo<ImageUint16>('Uint16', slope, intercept);\n    }\n\n    /**\n     * convert and copy this image in a new image 16bits\n     * @param slope multiplication factor applied to every pixel in the conversion\n     * @param intercept intercept used for every pixel in the conversion\n     */\n    convertTo32Float( slope? : number, intercept? : number) : ImageFloat32 {\n        return this.convertTo<ImageFloat32>('Float32', slope, intercept);\n    }\n\n    private convertTo<ImgType extends Image2D> (type : ImageType, slope? : number, intercept? : number) : ImgType {\n        let dstImage = ImageFactory.Image(type, this.width, this.height)\n        let dstPixels= dstImage.imagePixels\n        if( slope !=null  && intercept != null ){\n            dstPixels.forEach((v :number,i:number)=>dstPixels[i]=slope * this.buffer[i]+intercept)\n        } else {\n            dstPixels.forEach((v :number,i:number)=>dstPixels[i]=this.buffer[i])\n        }\n        return dstImage as ImgType\n    }\n\n    /**\n     * check that the value passed are valid image coordinates.\n     * @param x row\n     * @param y column\n     */\n    private checkBoundary(x: number, y : number ) : boolean {\n        return x>=0 && x < this.width && y>=0 && y<this.height\n    }\n\n}","import URLParams from \"../../app/urlParams\";\nimport BoundingBox from \"../../common/imgLib/BoundingBox\";\nimport ColourModels from \"../../common/imgLib/ColourModels\";\nimport Mask from \"../../common/imgLib/Mask\";\nimport { Bbox, Colour, Point } from \"../../common/imgLib/Types\";\nimport { LeafArea } from \"../../pages/process/ProcessSlice\";\n\nexport enum BackgroundType {\n    Image,\n    Transparent\n}\n\ninterface MaskWithLocation {\n    mask : Mask,\n    ulc  : Point\n}\n\n/**\n * This class perform the segmentation of the leaf, given the image and thresholds\n */\nexport default class LeafSeg {\n\n    private constructor( ) { } // singleton\n\n    /**\n     * Perform the identification of the leaf(s) in the input image\n     * @param imgData  input image\n     * @param hueThr  hue threshold [0,255]\n     * @param satThr saturation threshold [0,255]\n     * @param nLeafs number of leafs 1 or 2\n     * @returns areas : array with the areas measured, bboxs : bounding box for each leaf measured.\n     */\n    static Process(imgData : ImageData, hueThr : number, satThr : number, nLeafs : number, leafSet : Set<number>, pathSet:Set<number>, backgroundType: BackgroundType = BackgroundType.Image ) :  { areas : LeafArea[], bboxs : Bbox[] }  {\n\n        const leaves = LeafSeg.leafs(imgData, hueThr, satThr, nLeafs);\n        const pathogen= LeafSeg.pathogen(leaves, imgData, leafSet, pathSet);\n        const res    = LeafSeg.overlay(leaves, pathogen, imgData, backgroundType);\n        return res;\n    }\n\n    /**\n     * Packing Functions\n     * these are the function which packs the RGB values for the pathogen segementation.\n     * the colour model and the channel used in the packing heavily affect the generalization\n     * of the segmentation process.  See https://github.com/VittorioAccomazzi/LeafSize/issues/9\n     * @param r \n     * @param g \n     * @param b \n     * @returns token which encode the color's value.\n     */\n\n    // Note typescript dosn't directly support static constructors, and here I'm effectively\n    // creating one with an auto evaluation function\n    public static Pack : (r:number, g:number,b:number) => number = LeafSeg.SelectDefaultPacking();\n\n    // necessary for service worker where the URLParam is initialized latter\n    public static  SetPackFunction() {\n        LeafSeg.Pack = LeafSeg.SelectDefaultPacking();\n    }\n\n    private static SelectDefaultPacking () : (r:number, g:number,b:number) => number  {\n        let pack = LeafSeg.LabPack;\n        switch(URLParams.PackMode) {\n            case \"RGB\" : {\n                pack = LeafSeg.RgbPack;\n                break;\n            }\n            case \"HSV\": {\n                pack = LeafSeg.HsvPack;\n                break;\n            }\n        }\n        return pack;\n    }  \n\n    /**\n     * Packing function using the RGB component. Low generalization, but very easy control\n     * on the reagion to select.\n     */\n    private static RgbPack(r:number, g:number,b:number) : number {\n        return (r<<16)|(g<<8)|b\n    }\n\n    /**\n     * Packing function using the HSV model. \n     */\n    private static HsvPack(r:number, g:number,b:number) : number {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        \n       let {h,s} = ColourModels.Rgb2Hsv(r,g,b);\n\n       h = h|0;\n       s = (s*255)|0\n\n       return (h<<8)|s \n    }\n\n    /**\n     *  Packing function using the Lab model. Very good generalization, for tomato leaves.\n     */\n    private static LabPack(r:number, g:number,b:number) : number {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        \n       let {a,b:bb} = ColourModels.Rgb2Lab(r,g,b);\n\n       a  = (a*255/256)|0;\n       bb = (bb*255/256)|0; \n       a  += 128;\n       bb += 128;\n\n       //if( a< 0 || a > 255 ) throw Error(`a is ${a}`);\n       //if( bb<0 || bb> 255 ) throw Error (`b is ${b}`)\n\n       return (a<<8)|bb \n    }\n\n    /**\n     * Segment the pathogen areas of the leaves.\n     * @param leaves \n     * @param imgData \n     * @param leafSet \n     * @param pathSet \n     * @returns \n     */\n    private static pathogen ( leaves : Mask [], imgData : ImageData, leafSet : Set<number>, pathSet:Set<number> ) {\n        const pathMasks : MaskWithLocation [] = [];\n\n        if( pathSet.size > 0 ){\n            leaves.forEach(leaf=>{\n                const path = LeafSeg.getPathMask(leaf, imgData, leafSet, pathSet );\n                pathMasks.push(path);\n            })\n        }\n\n        return pathMasks;\n    }\n\n    private static overlay( leafs : Mask [], pathogen : MaskWithLocation[], imgData : ImageData, backgroundType : BackgroundType ) {\n        let areas: LeafArea[] = [];\n        let bboxs: Bbox[]= [];\n\n        // overlay\n        const colours : Colour [] = [{r:255,g:0,b:0},{r:255,g:255,b:0}];\n        const pathColor : Colour =  {r:255, g:128, b:0};\n\n        // set background\n        LeafSeg.setBackground(backgroundType, imgData);\n\n        leafs.forEach((m, i)=>{\n            const col  = colours[i%colours.length];\n            const leaf = m.area;\n            const bbox = m.Boundaries();\n            const path = pathogen[i]?.mask.area ?? 0;\n            areas.push({leaf,path});\n            bboxs.push(bbox);\n            const dil  = m.Dilate(1);\n            dil.Minus(m); // this is the outline.\n            dil.Overlay(imgData, col);  \n        })\n\n        pathogen.forEach(({mask, ulc})=>{\n            mask.Not();\n            const dMask = mask.Dilate(1);\n            dMask.Minus(mask);\n            dMask.Overlay(imgData, pathColor, ulc)\n        })\n\n        return {areas, bboxs}\n    }\n\n    private static leafs(imgData: ImageData, hueThr: number, satThr: number, nLeafs: number) {\n        const { hue, sat } = ColourModels.toHSV(imgData);\n        const rMask = new Mask(imgData.width, imgData.height);\n        const mPixels = rMask.imagePixels;\n        const hPixels = hue.imagePixels;\n        const sPixels = sat.imagePixels;\n\n        // background mask\n        hueThr *= 360 / 255; // rage expected by the library\n        satThr *= 1 / 255;\n        hPixels.forEach((v, i) => mPixels[i] = v > hueThr || sPixels[i] < satThr);\n\n        // fill holes\n        const bMask = rMask.Fill(1, 1);\n        const dMask = bMask;\n\n        // foregound mask\n        dMask.Not();\n\n        // extract components\n        const leafs = dMask.Components(nLeafs);\n\n        return leafs;\n    }\n\n    private static setBackground(backgroundType: BackgroundType, imgData: ImageData) {\n        const len = backgroundType === BackgroundType.Image ? 0 : imgData.data.length;\n        let data= imgData.data;\n        let ptr = 0;\n        while (ptr < len) {\n            data[ptr++] = 0;\n            data[ptr++] = 0\n            data[ptr++] = 0;\n            data[ptr++] = 0;\n        }\n    }\n\n    private static getPathMask(leaf : Mask, imgData : ImageData, leafSet : Set<number>, pathSet:Set<number>  ) : MaskWithLocation {\n        const tMask = new Mask(leaf.width, leaf.height);\n        const lPixels = leaf.imagePixels;\n        const pPixels = tMask.imagePixels;\n        const {data} = imgData;\n        let ptr = 0;\n\n        // Threshold the image\n        lPixels.forEach((v,i)=>{\n            if( v ){\n                const r = data[ptr++];\n                const g = data[ptr++];\n                const b = data[ptr++];\n                ptr++; // alpha\n                const val = LeafSeg.Pack(r,g,b);\n                pPixels[i] = !leafSet.has(val) && pathSet.has(val);\n            } else {\n                ptr += 4;\n            }\n        })\n\n        // dilate the image\n        const dMask = tMask.Dilate(1);\n\n        // Crop \n        const bbox = dMask.Boundaries();\n        const dBox = BoundingBox.Dilate(bbox, 1, 1);\n        const cMask= BoundingBox.CropMask(dBox, dMask);\n\n        // fill holes and opening.\n        cMask.Not(); // backgound mask\n        let bMask = cMask.Fill(0,0); \n        bMask = bMask.Dilate(2); // erosion\n        bMask.Not(); // foreground mask\n        bMask = bMask.Dilate(2); // dilation\n\n\n        // get largest component or an empty mask\n        const  comp = bMask.Components(1);\n        let path = comp.length ? comp[0] : new Mask(0,0)\n\n        return {\n            mask : path,\n            ulc  : dBox.ulc \n        };\n    }\n}","import { ImageFactory, ImageFloat32, ImageUint8 } from \"./ImageBase\";\nimport { ImageDataAllocator, imageDataAllocator } from \"./Types\";\n\n\n\nexport default class ColourModels {\n    static allocator = imageDataAllocator;\n\n    private constructor () { }  // singleton\n\n    /**\n     * Set the allocator for this class. Use for testing.\n     * @param imageDataAllocator functon which instiate the canvas's imagedata\n     */\n    static SetImageDataAllocator( imageDataAllocator  : ImageDataAllocator  ) : void {\n        ColourModels.allocator=imageDataAllocator\n    }\n\n    /**\n     * Generate a canvas from HSV components\n     * @param hImg hue image. Float image, with values from 0 to 360\n     * @param sImg saturation image. Float image with values from 0 to 1\n     * @param vImg value image. Float image with values from 0 to 1\n     */\n    static fromHSV( hImg : ImageFloat32, sImg : ImageFloat32, vImg : ImageFloat32) : ImageData {\n        let width = hImg.width\n        let height= hImg.height\n        let data = new Uint8ClampedArray( width * height * 4 );\n        let hPixels = hImg.imagePixels\n        let sPixels = sImg.imagePixels\n        let vPixels = vImg.imagePixels\n        let ptr =0;\n        for( let p=0; p<width*height; p++){\n            let h = hPixels[p]\n            let s = sPixels[p]\n            let v = vPixels[p]\n            let rgb = this.Hsv2Rgb(h,s,v)\n            data[ptr++] = rgb.r * 255\n            data[ptr++] = rgb.g * 255\n            data[ptr++] = rgb.b * 255\n            data[ptr++] = 255; // alpha \n        }\n        return ColourModels.allocator(data, width, height);\n    }\n\n    /**\n     *  decompose the current canvas in hue, saturation and value. \n     * @param image inpout canvas\n     * @returns hue : from 0 to 360, sat from 0 to 1, val from 0 to 1\n     */\n    static toHSV( image : ImageData ) : { hue : ImageFloat32, sat: ImageFloat32, val : ImageFloat32 } {\n        let width = image.width\n        let height= image.height\n        let hImg= ImageFactory.Float32(width,height)\n        let sImg= ImageFactory.Float32(width,height) \n        let vImg= ImageFactory.Float32(width,height) \n        let hPixels= hImg.imagePixels\n        let sPixels= sImg.imagePixels\n        let vPixels= vImg.imagePixels\n        let data= image.data\n        let ptr =0\n        for(let p=0; p<width*height;p++ ){\n            let r=data[ptr++];\n            let g=data[ptr++];\n            let b=data[ptr++];\n            ptr++; // alpha channel\n            let hsv = this.Rgb2Hsv(r/255, g/255, b/255);\n            hPixels[p]=hsv.h;\n            sPixels[p]=hsv.s;\n            vPixels[p]=hsv.v;\n        }\n        return { hue: hImg, sat : sImg, val : vImg }    \n    }\n    \n\n    /**\n     * convert the values in HSV coordinates\n     * @param r red value in   [0,1.0]\n     * @param g green value in [0,1.0]\n     * @param b blue value in [0,1.0]\n     * @returns h in [0,360], s in [0,1] and v in [0,1]\n     */\n     static Rgb2Hsv( r: number, g : number, b: number  ) : { h: number, s: number, v: number } {\n        // talen from https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both\n        let out = { h: 0, v:0, s: 0}\n        let min = Math.min(r,g,b)\n        let max = Math.max(r,g,b)\n        let delta = max-min\n        out.v = max;\n        if ( delta < 0.00001) {\n            out.h =0\n            out.s =0\n        } else {\n            out.s = delta/max\n            if( r === max ) out.h = 0 + (g-b)/delta\n            if( g === max ) out.h = 2 + (b-r)/delta\n            if( b === max ) out.h = 4 + (r-g)/delta\n        }\n\n        out.h *= 60 // in degrees\n        if( out.h < 0 ) out.h += 360\n\n        return out\n    }\n\n    /**\n     * \n     * @param h [0,360]\n     * @param s [0,1]\n     * @param v [0,1]\n     * @returns r [0,255] g [0,255] and b [0,255]\n     */\n    static Hsv2Rgb(h:number, s:number, v:number) : {r:number, g:number, b:number} {\n        // from https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both\n        let out = { r:v, g:v, b:v}\n        if( s > 0 ){\n            let hh = h / 60\n            let region = Math.floor(hh)\n            let reminder = hh - region\n            let p = v * ( 1- s )\n            let q = v * ( 1- (s * reminder))\n            let t = v * ( 1- (s * (1 - reminder)))\n            switch( region ){\n                case 0: \n                    out.r = v\n                    out.g = t\n                    out.b = p\n                    break;\n                case 1:\n                    out.r = q\n                    out.g = v\n                    out.b = p\n                    break;\n                case 2:\n                    out.r = p\n                    out.g = v\n                    out.b = t\n                    break\n                case 3:\n                    out.r = p\n                    out.g = q\n                    out.b = v\n                    break\n                case 4:\n                    out.r = t\n                    out.g = p\n                    out.b = v\n                    break\n                default:\n                    out.r = v\n                    out.g = p\n                    out.b = q\n            }\n        }\n\n        return out\n    }\n\n    /**\n     * generate a canvas from a LAB image : components using Observer= 2Â°, Illuminant= D65\n     * see https://en.wikipedia.org/wiki/CIELAB_color_space\n     * @param lImg light image\n     * @param aImg \n     * @param bImg \n     * @returns \n     */\n    static fromLab( lImg : ImageFloat32, aImg : ImageFloat32, bImg : ImageFloat32) : ImageData {\n        let width = lImg.width\n        let height= lImg.height\n        let data = new Uint8ClampedArray( width * height * 4 );\n        let lPixels = lImg.imagePixels\n        let aPixels = aImg.imagePixels\n        let bPixels = bImg.imagePixels\n        let ptr =0;\n        for( let p=0; p<width*height; p++){\n            let l = lPixels[p]\n            let a = aPixels[p]\n            let b = bPixels[p]\n            let rgb = this.Lab2Rgb(l,a,b)\n            data[ptr++] = rgb.r * 255;\n            data[ptr++] = rgb.g * 255;\n            data[ptr++] = rgb.b * 255;\n            data[ptr++] = 255; // alpha\n        }\n        return ColourModels.allocator(data, width, height);\n    }\n\n     /**\n     * convert the input canvas, assumed to be un RGB space, in to LAB\n     * components using Observer= 2Â°, Illuminant= D65\n     * @param image input image\n     */\n        static toLab(image : ImageData ) : { l : ImageFloat32, a : ImageFloat32, b :ImageFloat32 } {\n        let width = image.width\n        let height= image.height\n        let lImg= ImageFactory.Float32(width,height)\n        let aImg= ImageFactory.Float32(width,height) \n        let bImg= ImageFactory.Float32(width,height) \n        let lPixels= lImg.imagePixels\n        let aPixels= aImg.imagePixels\n        let bPixels= bImg.imagePixels\n        let data= image.data\n        let ptr =0\n        for(let p=0; p<width*height;p++ ){\n            let r=data[ptr++];\n            let g=data[ptr++];\n            let b=data[ptr++];\n            ptr++; // alpha channel\n            let lab = this.Rgb2Lab(r/255, g/255, b/255);\n            lPixels[p]=lab.l;\n            aPixels[p]=lab.a;\n            bPixels[p]=lab.b;\n        }\n        return { l: lImg, a: aImg, b: bImg}    \n    }\n\n    // Taken from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n    // which in turns is taken from the heavily referenced web site :\n    // https://www.easyrgb.com/en/math.php\n    static Rgb2Lab(r: number, g: number, b: number) : { l: number, a:number, b:number } {\n  \n        r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n        g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n        b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n    \n        let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;\n        let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;\n        let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;\n    \n        x = (x > 0.008856) ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;\n        y = (y > 0.008856) ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;\n        z = (z > 0.008856) ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;\n    \n        return { l : (116 * y) - 16, a: 500 * (x - y), b: 200 * (y - z) }\n    }\n\n    static Lab2Rgb(l: number, a: number, b: number) {\n        let y = (l + 16) / 116\n        let x = a / 500 + y\n        let z = y - b / 200\n  \n        x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16/116) / 7.787);\n        y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16/116) / 7.787);\n        z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16/116) / 7.787);\n\n        let rgb = {\n            r : x *  3.2406 + y * -1.5372 + z * -0.4986,\n            g : x * -0.9689 + y *  1.8758 + z *  0.0415,\n            b : x *  0.0557 + y * -0.2040 + z *  1.0570\n        }\n    \n        rgb.r = (rgb.r > 0.0031308) ? (1.055 * Math.pow(rgb.r, 1/2.4) - 0.055) : 12.92 * rgb.r;\n        rgb.g = (rgb.g > 0.0031308) ? (1.055 * Math.pow(rgb.g, 1/2.4) - 0.055) : 12.92 * rgb.g;\n        rgb.b = (rgb.b > 0.0031308) ? (1.055 * Math.pow(rgb.b, 1/2.4) - 0.055) : 12.92 * rgb.b;\n\n        rgb.r = Math.max(0, Math.min(1,rgb.r))\n        rgb.g = Math.max(0, Math.min(1,rgb.g))\n        rgb.b = Math.max(0, Math.min(1,rgb.b))\n\n        return rgb\n    }\n\n    /**\n     *  Generate the canvas's channels (red, green, blue and alpha) in separate images.\n     * @param canvas \n     */\n        static toRGB( canvas : ImageData ) : { r : ImageUint8, g : ImageUint8, b : ImageUint8 } {\n            let width = canvas.width;\n            let height= canvas.height;\n            let imgR= ImageFactory.Uint8(width,height);\n            let imgG= ImageFactory.Uint8(width,height);\n            let imgB= ImageFactory.Uint8(width,height);\n            let nPixels = width*height;\n            let i =0;\n            let cPixels = canvas.data;\n            let rPixels = imgR.imagePixels;\n            let gPixels = imgG.imagePixels;\n            let bPixels = imgB.imagePixels;\n        \n            for( let p=0; p<nPixels; p++){\n                rPixels[p]=cPixels[i++];\n                gPixels[p]=cPixels[i++];\n                bPixels[p]=cPixels[i++];\n                i++; // skip alpha\n            }\n\n            return { r: imgR, g: imgG, b :imgB }\n        }\n    \n        /**\n         * generate a ImageData object using the images provided as channels.\n         * @param imgR \n         * @param imgG \n         * @param imgB \n         */\n        static fromRGB( imgR : ImageUint8, imgG : ImageUint8, imgB : ImageUint8 ): ImageData {\n            let width = imgR.width;\n            let height= imgR.height;\n            let nPixels = width*height;\n            let i =0;\n            let cPixels = new Uint8ClampedArray( width * height * 4 );\n            let rPixels = imgR.imagePixels;\n            let gPixels = imgG.imagePixels;\n            let bPixels = imgB.imagePixels;\n        \n            for( let p=0; p<nPixels; p++){\n                cPixels[i++] = rPixels[p];\n                cPixels[i++] = gPixels[p];\n                cPixels[i++] = bPixels[p];\n                cPixels[i++] = 255;\n            }\n    \n            return ColourModels.allocator(cPixels,width,height)\n        }\n}","// the next line declare that we are in the web workers\n\n/// <reference lib=\"webworker\" />\n\n//\n// Using the model directly supported by Webpack 5 https://webpack.js.org/guides/web-workers/\n//\n\nimport { LeafArea } from \"../../pages/process/ProcessSlice\";\nimport { imageSize } from \"../../app/const\";\nimport ImageLoader from \"../foreground/ImageLoader\";\nimport LeafCrop from \"./LeafCrop\";\nimport LeafSeg from \"./LeafSeg\";\nimport URLParams from \"../../app/urlParams\";\n\nexport interface QueryMessage {\n    file    : FileSystemFileHandle, \n    nDishes : number,\n    name    : string,\n    hueThr  : number, \n    satThr  : number, \n    nLeafs  : number,\n    urlParam: string,\n    leafVals: number [],\n    pathVals: number []\n}\n\nexport interface AnswerMessage {\n    imgData : ImageData, \n    areas   : LeafArea[]\n}\n\n/* eslint-disable-next-line no-restricted-globals */\nself.onmessage=async (ev:MessageEvent<QueryMessage>)=> {\n    const {file, name, nDishes, hueThr, satThr, nLeafs, leafVals, pathVals, urlParam } = ev.data\n    URLParams.SetSearchParam(urlParam); // set default values.\n    LeafSeg.SetPackFunction(); // set pack function based on the URLParams.\n    const imgLoader = new ImageLoader([file], nDishes, imageSize);\n    const imgIndex  = imgLoader.List.indexOf(name);\n    const {imgData, scale} = await imgLoader.getImage(imgIndex)\n    const {areas, bboxs } = LeafSeg.Process(imgData!, hueThr, satThr, nLeafs, new Set(leafVals), new Set(pathVals));\n    const result = LeafCrop.Process(areas, bboxs, imgData!, scale);\n    sendMessage(result);\n}\n\nfunction sendMessage( msg : AnswerMessage ) {\n    /* eslint-disable-next-line no-restricted-globals */\n    self.postMessage(msg);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [271], function() { return __webpack_require__(765); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"e722dad0\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/LeafSize/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t765: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkleafsize\"] = self[\"webpackChunkleafsize\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(271).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","noExtension","filename","index","lastIndexOf","res","substring","ImageLoader","files","numDishes","targetSize","imageFileLoader","getImageFromFile","tiles","cacheImage","cacheFile","this","Error","map","file","quadrant","name","forEach","push","f","find","v","Set","size","scale","imgData","length","tile","getImageFromCache","img","imgWidth","width","imgHeight","height","xTopLft","yTopLft","xBtmRgt","yBtmRgt","xMid","yMid","srcWidth","srcHeight","srcDiag","Math","sqrt","min","dstWidth","dstHeight","document","canvas","OffscreenCanvas","createElement","ctx","getContext","drawImage","getImageData","close","handle","getFile","arrayBuffer","data","blob","Blob","createImageBitmap","Mask","pixels","w","Array","fill","reduce","s","x","y","checkSize","srcMask","i","func","val","xSeed","ySeed","inpPixels","outMask","outPixels","imagePixels","NeigbourdPoints","stack","pt","shift","p","offset","halfSize","IsEmpty","Clone","foreachPixel","len","yk","off","r","g","b","a","xOffset","yOffset","ptr","alpha","weight","imgStride","maskLast","incr","red","green","blue","num","list","mask","Fill","area","sort","Minus","xMin","yMin","xMax","yMax","BoundingBox","FromValues","imageDataAllocator","ImageData","allocator","pt1","pt2","x1","y1","x2","y2","xmin","xmax","max","ymin","ulc","imageData","bbox","boxes","box","Empty","ymax","dx","dy","imageBox","FromImage","int","Intersect","dst","Uint8ClampedArray","src","dstPt","srcPt","inpMask","inpWidth","outPtr","inPtr","inEnd","LeafCrop","areas","bboxs","Merge","leafData","leafAreas","rescale","wDilation","hDilation","dBox","Dilate","CropImage","aInfo","leaf","path","URLParams","urlParams","params","URLSearchParams","get","window","location","search","BackgroundType","ImageFactory","ImageBase","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Float32Array","type","Uint8","Uint16","Float32","elementSize","constructor","buffer","nPixels","ArrayBuffer","from","e","replace","imageType","checkBoundary","idx","value","slope","intercept","convertTo","dstImage","Image","dstPixels","ColourModels","hImg","sImg","vImg","hPixels","sPixels","vPixels","h","rgb","Hsv2Rgb","image","hsv","Rgb2Hsv","hue","sat","out","delta","hh","region","floor","reminder","q","t","lImg","aImg","bImg","lPixels","aPixels","bPixels","l","Lab2Rgb","lab","Rgb2Lab","pow","z","imgR","imgG","imgB","cPixels","rPixels","gPixels","LeafSeg","hueThr","satThr","nLeafs","leafSet","pathSet","backgroundType","leaves","leafs","pathogen","overlay","Pack","SelectDefaultPacking","pack","LabPack","PackMode","RgbPack","HsvPack","bb","pathMasks","getPathMask","colours","pathColor","setBackground","m","col","Boundaries","dil","Overlay","Not","dMask","toHSV","rMask","mPixels","Components","tMask","pPixels","has","cMask","CropMask","bMask","comp","self","onmessage","ev","nDishes","leafVals","pathVals","urlParam","SetSearchParam","SetPackFunction","imgLoader","imgIndex","List","indexOf","getImage","Process","result","msg","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","splice","n","getter","__esModule","d","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}
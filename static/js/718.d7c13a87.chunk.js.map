{"version":3,"file":"static/js/718.d7c13a87.chunk.js","mappings":"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","sources":["app/const.ts","common/utils/FileUtils.ts","workers/foreground/ImageLoader.ts","common/imgLib/Types.ts","common/imgLib/BoundingBox.ts","workers/background/LeafCrop.ts","common/imgLib/ImageBase.ts","common/imgLib/ColourModels.ts","common/imgLib/Mask.ts","workers/background/LeafSeg.ts","workers/background/LeafSegWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const root = \"/LeafSize/\";\nexport const settingsPath  = `${root}settings`;\nexport const selectionPath = `${root}`;\nexport const processingPath= `${root}process`;\nexport const resultPath    = `${root}result`;\nexport const imageSize     =1024;\nexport const dilation = 25;\nexport const minWidth = 256;\nexport const minHeight= 256;\nexport const GAUID    = \"G-2TD0F8G11B\";\n","const imageExtensions = ['.png', '.gif', '.jpeg', '.jpg'];\n\nexport default function isImage( name : string ) : boolean {\n  const lower = name.toLowerCase();\n  return imageExtensions.map( ext =>lower.endsWith(ext)).some((val)=>val)\n}\n\n// 🖐 Node modules are no longer polyfilled in webpack 5. To enable that I should eject the solution.\n// since what I do here is very simple, I just implement it.\n// see https://stackoverflow.com/questions/64557638/how-to-polyfill-node-core-modules-in-webpack-5\nexport function noExtension( filename : string  ) : string {\n  const index = filename.lastIndexOf(\".\");\n  let res = filename;\n  if( index > 0 ){ // on purpose we skip position 0\n    res = filename.substring(0,index);\n  }\n  return res;\n}\n\nexport const  wait = async ( ms : number ) => new Promise(res=>setTimeout(res, ms))","import {noExtension} from '../../common/utils/FileUtils'\n\ntype Quadrant = 'Q0' | 'Q1' | 'Q2' | 'Q3' | 'All'\n\n// this interfce is designed to facilitate the testing (inversion of dependencies )\nexport interface ImgLoaderFileHandle {\n    name : string,\n    getFile : ()=>Promise<ImgLoaderFile>\n}\n\n\nexport interface ImgLoaderFile {\n    arrayBuffer : () => Promise<ArrayBuffer>\n}\n\ninterface ImageTile {\n    file :  ImgLoaderFileHandle //FileSystemHandle,\n    name : string,\n    quadrant : Quadrant\n}\n\nexport type ImageFileLoader =  ( handle : ImgLoaderFileHandle ) => Promise<ImageBitmap> \n\n/**\n * Image loader.\n * Load the images from file and split them up as necessary.\n */\nexport default class ImageLoader  {\n    private tiles : ImageTile[] = []\n    private cacheImage : ImageBitmap | null = null;\n    private cacheFile  : ImgLoaderFileHandle | null = null;\n    private getImageFromFile : ImageFileLoader\n    private targetSize : number;\n\n    /**\n     * construct a ImageLoader object\n     * @param files list of files to load\n     * @param numDishes  number of dishes per image : 1 or 4\n     * @param targetSize  target size for the image's diagonal.\n     * @param imageFileLoader loader function (if required)\n     */\n    constructor ( files : ImgLoaderFileHandle[] | null , numDishes : number, targetSize : number, imageFileLoader : ImageFileLoader = getImageFromFile ){\n        this.tiles = []\n        this.getImageFromFile = imageFileLoader;\n        this.targetSize = targetSize;\n        if (numDishes !==1 && numDishes !== 4 ) throw new Error(`not supported num Dishes ${numDishes}`)\n\n        if( files ){\n            switch(numDishes){\n                case 1: {\n                    this.tiles = files.map(file => ({ file, quadrant : 'All', name : noExtension(file.name)}))\n                    break;\n                }\n                case 4: {\n                    files.forEach(file =>{\n                        ['Q0','Q1','Q2','Q3'].forEach(quadrant=>{\n                            this.tiles.push({\n                                file,\n                                name : noExtension(file.name)+'-'+quadrant,\n                                quadrant : quadrant as Quadrant\n                            })\n                        })\n                    })\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * list of images generated\n     */\n    get List() : string [] {\n        return this.tiles.map(f=>f.name);\n    }\n\n    /**\n     * get file handle given the image name\n     */\n    FileHandle( name : string ) :ImgLoaderFileHandle | undefined {\n        return this.tiles.find(v=>v.name===name)?.file;\n    }\n\n    /**\n     * number of dishes for image\n     */\n    get NumDishes() : number {\n        let qList = new Set(this.tiles.map(v=>v.quadrant));\n        return qList.size;\n    }\n\n    /**\n     * Extract an image from the file.\n     * @param inCanvas canvas where the image will be copied to.\n     * @param index index of the image to extract\n     * @returns scale : downsample value of the original image in order to reach the diagonal size set in the constructor. imageData : image Data for the canvas object\n     */\n    async getImage( index : number ): Promise< { scale : number, imgData : ImageData|null }> {\n        let scale = 0;\n        let imgData = null;\n        if( !this.tiles || !this.tiles.length ) return {scale, imgData }; // this can happen as transition\n        if( index <0 || index >this.tiles.length) throw Error(`undexpected index : requested ${index} but got ${this.tiles.length}`)\n        const tile = this.tiles[index];\n        const img = await this.getImageFromCache( tile );\n        const imgWidth = img.width;\n        const imgHeight= img.height;\n        let xTopLft = 0;\n        let yTopLft = 0;\n        let xBtmRgt = imgWidth;\n        let yBtmRgt = imgHeight;\n        const xMid = imgWidth/2 | 0;\n        const yMid = imgHeight/2 | 0;\n        switch( tile.quadrant ){\n            case 'Q0' : {\n                xTopLft = 0;\n                yTopLft = 0;                \n                xBtmRgt = xMid;\n                yBtmRgt = yMid;\n                break;\n            }\n            case 'Q1' : {\n                xTopLft = xMid;\n                yTopLft = 0;\n                xBtmRgt = imgWidth;\n                yBtmRgt = yMid;\n                break;\n            }\n            case 'Q2' : {\n                xTopLft = 0;\n                yTopLft = yMid;                \n                xBtmRgt = xMid;\n                yBtmRgt = imgHeight;\n                break;\n            }\n            case 'Q3' : {\n                xTopLft = xMid;\n                yTopLft = yMid;                \n                xBtmRgt = imgWidth;\n                yBtmRgt = imgHeight;\n                break;\n            }\n        }\n        const srcWidth = xBtmRgt-xTopLft;\n        const srcHeight= yBtmRgt-yTopLft;\n        const srcDiag = Math.sqrt(srcHeight*srcHeight+srcWidth*srcWidth);\n        scale = Math.min( 1, this.targetSize/srcDiag);\n        const dstWidth = srcWidth * scale;\n        const dstHeight= srcHeight * scale;\n\n        // we need to get to the pixel data, and so we need a canvas (unfortunately)\n        // see https://github.com/whatwg/html/issues/4785\n        // Note OffscreenCanvas is deprecated below because it is experimental \n        // see https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas/OffscreenCanvas \n        // however since this will run in the workers I have no othre option.\n        let canvas : HTMLCanvasElement | OffscreenCanvas;\n        if( typeof document === 'undefined' ) {\n            // worker\n            canvas = new OffscreenCanvas(dstWidth, dstHeight);\n        } else {\n            // window\n            canvas = document.createElement('canvas')\n            canvas.width = dstWidth;\n            canvas.height= dstHeight;\n        }\n\n        // Extract the pixel data which is needed for further processing.\n        const ctx = canvas.getContext('2d');\n        if( ctx ) { \n            ctx.drawImage( img, xTopLft, yTopLft, srcWidth, srcHeight, 0, 0, dstWidth, dstHeight);\n            imgData = ctx.getImageData(0,0,dstWidth, dstHeight);\n            // Debug only\n            // ctx.font = '48px serif'; // debug only.\n            // ctx.fillText(tile.name, 10, 60);\n        }\n        return { scale, imgData }\n    }\n\n    /**\n     * This function perform some simple caching on the images because when the user is settings 4 dishes per image,\n     * we can effectively load the same image for 4 different request.\n     * @param tile tile which describes the images to extract.\n     * @returns \n     */\n    private async getImageFromCache( tile : ImageTile  ) : Promise<ImageBitmap> {\n        if( this.cacheFile !== tile.file  ){\n            if( this.cacheImage ) this.cacheImage.close(); // free resources.\n            this.cacheImage = await this.getImageFromFile( tile.file );\n            this.cacheFile  = tile.file;\n        } \n        return this.cacheImage!;\n    }\n}\n\n    /**\n     * Load the image from file.\n     * @param handle file to load\n     * @returns \n     */\n     async function getImageFromFile( handle : ImgLoaderFileHandle ) : Promise<ImageBitmap> {\n        const file = await handle.getFile();\n        const data = await file.arrayBuffer();\n        const blob = new Blob([data]);\n        return createImageBitmap(blob);\n    }","\n/**\n * definition of a colour. Each channel is considered an 8 bit integer.\n * the values are *not* pre multiplied by alpha. If alpha is not present \n * it is considered 255, and so the colour is fully opaque.\n */\nexport interface Colour {\n    r : number,\n    g : number,\n    b : number,\n    a?: number\n}\n\n/**\n * 2D point. Defined here because DOMPoint requires many more parameters\n * which are not necessary for the imgLib purposes.\n */\nexport interface Point {\n    x: number,\n    y: number\n}\n\n\n/**\n * defines a bondung box.\n */\nexport interface Bbox {\n    ulc : Point,\n    size: {\n        width : number,\n        height: number\n    }\n}\n\n/**\n * generic interface for an image/mask object. Something which can be displayed and/or overlayed on an image.\n */\nexport default interface IImage<T> {\n    readonly width : number,\n    readonly height: number,\n    set : (x:number, y:number, v : T )=> void,\n    get : (x:number, y:number) => T,\n    foreachPixel : (func:(x:number, y:number, v:T)=>void)=>void\n}\n\n/* unfortunately this is necesary in order to deal with the jest dom, which doesn't support the\n * ImageData object and the browser dom.\n */\n\nexport type ImageDataAllocator = ( data : Uint8ClampedArray, width : number, height : number ) => ImageData;\n\nexport const imageDataAllocator = ( data : Uint8ClampedArray, width : number, height : number ) : ImageData =>{\n    return new ImageData(data, width, height);\n}","import { Bbox, Point } from \"./Types\";\nimport { ImageDataAllocator, imageDataAllocator } from \"./Types\";\n\n/**\n * simple class to manipulate bounding boxes.\n */\nexport default class BoundingBox  {\n\n    static allocator = imageDataAllocator;\n\n    private constructor () { }  // singleton\n\n    /**\n     * Set the allocator for this class. Use for testing.\n     * @param imageDataAllocator functon which instiate the canvas's imagedata\n     */\n    static SetImageDataAllocator( imageDataAllocator  : ImageDataAllocator  ) : void {\n        BoundingBox.allocator=imageDataAllocator\n    }\n\n    static FromPoints( pt1 : Point, pt2 : Point ){\n        return BoundingBox.FromValues(pt1.x, pt1.y, pt2.x, pt2.y);\n    }\n\n    static FromValues( x1 : number, y1 : number, x2 : number, y2 : number ) : Bbox {\n        const xmin = Math.min(x1, x2);\n        const xmax = Math.max(x1, x2);\n        const ymin = Math.min(y1, y2);\n        const ymax = Math.max(y1, y2);\n        return {\n            ulc : {\n                x: xmin,\n                y: ymin\n            },\n            size : {\n                width : xmax-xmin,\n                height: ymax-ymin\n            }\n        }\n    }\n\n    static get Empty() : Bbox {\n        return {\n            ulc : {x:0, y:0},\n            size: {width:0, height:0}\n        }\n    }\n\n    static IsEmpty(bbox:Bbox) : boolean {\n        return bbox.size.width <=0 || bbox.size.height <= 0;\n    }\n\n    static Merge( boxes : Bbox[] ) : Bbox {\n        let box =  BoundingBox.Empty;\n        if( boxes.length > 0 ){\n            let xmin = boxes[0].ulc.x;\n            let ymin = boxes[0].ulc.y;\n            let xmax = xmin;\n            let ymax = ymin;\n            boxes.forEach(b=>{\n                xmin = Math.min(b.ulc.x, xmin);\n                ymin = Math.min(b.ulc.y, ymin);\n                xmax = Math.max(b.ulc.x+b.size.width, xmax);\n                ymax = Math.max(b.ulc.y+b.size.height, ymax);\n            })\n            box = BoundingBox.FromValues(xmin, ymin, xmax, ymax);\n        }\n        return box;\n    }\n\n    static Dilate(bbox:Bbox, dx : number, dy: number ): Bbox{\n        return {\n            ulc : { x: bbox.ulc.x-dx, y:bbox.ulc.y-dy},\n            size: { width : bbox.size.width+2*dx, height : bbox.size.height+2*dy}\n        }\n    }\n\n    static Intersect(boxes : Bbox[] ) : Bbox {\n        let box =  BoundingBox.Empty;\n        if( boxes.length > 0 ){\n            let xmin = boxes[0].ulc.x;\n            let ymin = boxes[0].ulc.y;\n            let xmax = xmin+boxes[0].size.width;\n            let ymax = ymin+boxes[0].size.height;\n            boxes.forEach(b=>{\n                xmin = Math.max(b.ulc.x, xmin);\n                ymin = Math.max(b.ulc.y, ymin);\n                xmax = Math.min(b.ulc.x+b.size.width, xmax);\n                ymax = Math.min(b.ulc.y+b.size.height, ymax);\n            })\n            box = {\n                ulc: {x:xmin, y:ymin},\n                size:{width:xmax-xmin, height:ymax-ymin}\n            }\n        }\n        return box;\n    }\n\n    static CropImage(bbox : Bbox, imageData : ImageData ) : ImageData | null {\n        const imageBox = {\n            ulc : {x:0, y:0},\n            size: {width:imageData.width, height:imageData.height}\n        }\n        \n        const int = BoundingBox.Intersect([bbox, imageBox]);\n        let res : ImageData | null = null;\n\n        if( !BoundingBox.IsEmpty(int) ){\n            const width = int.size.width;\n            const height= int.size.height;\n            const dst = new Uint8ClampedArray(width*height*4);\n            const src = imageData.data;\n            let dstPt = 0;\n\n            for( let y=int.ulc.y; y<int.ulc.y+height; y++){\n                let srcPt= ( y* imageData.width+ bbox.ulc.x ) * 4;\n                for( let x=0; x<width; x++ ){\n                    dst[dstPt++] = src[srcPt++];\n                    dst[dstPt++] = src[srcPt++];\n                    dst[dstPt++] = src[srcPt++];\n                    dst[dstPt++] = src[srcPt++];\n                }\n            }\n\n            res = BoundingBox.allocator(dst, width, height);\n        }\n\n        return res;\n    }\n\n}","import { dilation, minHeight, minWidth } from \"../../app/const\";\nimport BoundingBox from \"../../common/imgLib/BoundingBox\";\nimport { Bbox } from \"../../common/imgLib/Types\";\n\n\n\n/**\n * simple class to crop the image based on the bounding box\n */\nexport default class LeafCrop {\n    private constructor() {} // singleton\n\n    static Process( areas : number[], bboxs : Bbox[], imgData : ImageData, scale : number ) {\n        const box = BoundingBox.Merge(bboxs);\n        let leafData  : ImageData = imgData;\n        let leafAreas : number [] = [];\n        if( !BoundingBox.IsEmpty(box) ){\n            let wDilation = dilation;\n            let hDilation = dilation;\n            if( box.size.width < minWidth ) wDilation = Math.max(wDilation, ( minWidth-box.size.width)/2|0);\n            if( box.size.height< minHeight) hDilation = Math.max(hDilation, ( minHeight-box.size.height)/2|0);\n            const dBox = BoundingBox.Dilate(box, wDilation, hDilation);\n            leafData = BoundingBox.CropImage(dBox, imgData)!;\n            leafAreas= areas.map(v=>(v/(scale*scale)|0));\n        }\n        return {\n            imgData : leafData,\n            areas : leafAreas\n        };\n    }\n}","import IImage from \"./Types\";\n\ninterface TypedArray {\n    readonly length : number;\n    [n: number]: number;\n    buffer : ArrayBuffer;\n    reduce ( func : (total : number, currentValue : number, index : number ) => number, initialvalue : number) : number;\n}\n\ninterface TypedArrayConstructor<T extends TypedArray> {\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): T;\n}\n\nexport type ImageUint8  = ImageBase<Uint8Array,Uint8ArrayConstructor>\nexport type ImageUint16 = ImageBase<Uint16Array,Uint16ArrayConstructor>\nexport type ImageFloat32= ImageBase<Float32Array,Float32ArrayConstructor>\n\n// this is the generic Image type. Using this approach we avoid to expose\n// the complexity of the generic used below.\n\nexport type Image2D = ImageUint8 | ImageUint16 | ImageFloat32\nexport type ImagePixels = Uint8Array | Uint16Array | Float32Array\nexport type ImageType = 'Uint8' | 'Uint16' | 'Float32'\n\n\nexport function isImage( obj : any ) : obj is Image2D {\n    return obj.constructor.name === \"ImageBase\"\n}\n\nexport class ImageFactory {\n\n    static Uint8( width : number, height : number ) : ImageUint8 {\n        return new ImageBase<Uint8Array,Uint8ArrayConstructor>(Uint8Array.BYTES_PER_ELEMENT, Uint8Array, width, height)\n    }\n    static Uint16( width : number, height : number ) : ImageUint16{\n        return (new ImageBase<Uint16Array,Uint16ArrayConstructor>(Uint16Array.BYTES_PER_ELEMENT, Uint16Array, width, height)) \n    }\n    static Float32( width : number, height : number ): ImageFloat32{\n        return new ImageBase<Float32Array,Float32ArrayConstructor>(Float32Array.BYTES_PER_ELEMENT, Float32Array, width, height)\n    }\n    static Image(type : ImageType, width : number, height : number ) : Image2D {\n        switch( type ){\n            case 'Uint8':\n                return ImageFactory.Uint8(width,height)\n            case 'Uint16':\n                return ImageFactory.Uint16(width,height)\n            case 'Float32':\n                return ImageFactory.Float32(width,height)\n        }\n    }\n}\n\n\nclass ImageBase<T extends TypedArray, C extends TypedArrayConstructor<T>>  implements IImage<number> {\n\n    private buffer : T\n    private pixels : T [] \n\n    constructor( elementSize : number, constructor : C, width : number, height : number ) {\n        let nPixels= width * height;\n        let bytes  = nPixels * elementSize\n        let buffer= new ArrayBuffer(bytes);\n        this.pixels= Array.from(Array(height), (e,i)=> new constructor (buffer, width*elementSize*i, width) ) \n        this.buffer= new constructor(buffer, 0, nPixels)\n    }\n\n\n    /**\n     * get type of pixel stored.\n     */\n    get imageType(): ImageType {\n        return this.pixels[0].constructor.name.replace('Array','') as ImageType\n    }\n\n    /**\n     * returns the current list of pixels.\n     */\n    get imagePixels(): T {\n        return this.buffer \n    }\n\n    /**\n     *  get the image buffer\n     */\n    get imageBuffer() : ArrayBuffer {\n        return this.buffer.buffer\n    }\n\n    /**\n     * get image height\n     */\n    get height() : number {\n        return this.pixels.length\n    }\n\n    /**\n     * return image height\n     */\n    get width() : number {\n        return this.pixels[0].length\n    }\n\n    /*\n    * overwrite toString in order to provide information when the image is printed\n    */\n    toString() : string {\n       return `image ${this.imageType} ${this.width}x${this.height}`\n    }\n\n    /**\n     * get a pixel value.\n     * @param x row of the pixel queried\n     * @param y column of the pixel queried\n     */\n    get( x: number, y: number ) : number {\n        if( !this.checkBoundary(x,y)) throw new Error (`Invalid image coordinates queried: image size ${this.width}x${this.height} pixel ${x},${y}`)\n        return this.pixels[y][x]\n    }\n\n    /**\n     * loop thought all the pixel in the image\n     * @param func function to process each pixel in the image\n     */\n    foreachPixel (func : (x:number, y:number, v: number )=> void) : void  {\n        this.pixels.forEach((val, y)=>{ for(let x=0; x<val.length;x++) func(x,y,val[x])})\n    }\n\n    /**\n     * max pixel value in the image\n     */\n    maxValue() : number {\n        return this.buffer.reduce((max, val, idx)=>Math.max(val,max),this.buffer[0])\n    }\n\n    /**\n     * min pixel value in the image\n     */\n    minValue() : number {\n        return this.buffer.reduce((min, val, idx)=>Math.min(val,min),this.buffer[0])\n    }\n\n    /**\n     * get a row of pixels\n     * @param y row of pixels to select.\n     */\n    getRow(y:number) : T {\n        if( y<0 || y>this.height )throw new Error (`Invalid y coordinate queried : image height ${this.height} y ${y}`)\n        return this.pixels[y]\n    }\n\n    /**\n     * \n     * @param x row pixel to set\n     * @param y column pixel to se\n     * @param value  value to set\n     */\n    set(x:number, y:number, value : number) : void {\n        if( !this.checkBoundary(x,y)) throw new Error (`Invalid image coordinates set: image size ${this.width}x${this.height} pixel ${x},${y}`)\n        this.pixels[y][x]= value\n    }\n\n    /**\n     * convert and copy this image in a new image 8bit\n     * @param slope multiplication factor applied to every pixel in the conversion\n     * @param intercept intercept used for every pixel in the conversion\n     */\n    convertTo8Uint( slope? : number, intercept? : number) : ImageUint8 {\n        return this.convertTo<ImageUint8>('Uint8', slope, intercept);\n    }\n\n    /**\n     * convert and copy this image in a new image 16bits\n     * @param slope multiplication factor applied to every pixel in the conversion\n     * @param intercept intercept used for every pixel in the conversion\n     */\n    convertTo16Uint( slope? : number, intercept? : number) : ImageUint16 {\n        return this.convertTo<ImageUint16>('Uint16', slope, intercept);\n    }\n\n    /**\n     * convert and copy this image in a new image 16bits\n     * @param slope multiplication factor applied to every pixel in the conversion\n     * @param intercept intercept used for every pixel in the conversion\n     */\n    convertTo32Float( slope? : number, intercept? : number) : ImageFloat32 {\n        return this.convertTo<ImageFloat32>('Float32', slope, intercept);\n    }\n\n    private convertTo<ImgType extends Image2D> (type : ImageType, slope? : number, intercept? : number) : ImgType {\n        let dstImage = ImageFactory.Image(type, this.width, this.height)\n        let dstPixels= dstImage.imagePixels\n        if( slope !=null  && intercept != null ){\n            dstPixels.forEach((v :number,i:number)=>dstPixels[i]=slope * this.buffer[i]+intercept)\n        } else {\n            dstPixels.forEach((v :number,i:number)=>dstPixels[i]=this.buffer[i])\n        }\n        return dstImage as ImgType\n    }\n\n    /**\n     * check that the value passed are valid image coordinates.\n     * @param x row\n     * @param y column\n     */\n    private checkBoundary(x: number, y : number ) : boolean {\n        return x>=0 && x < this.width && y>=0 && y<this.height\n    }\n\n}","import { ImageFactory, ImageFloat32, ImageUint8 } from \"./ImageBase\";\nimport { ImageDataAllocator, imageDataAllocator } from \"./Types\";\n\n\n\nexport default class ColourModels {\n    static allocator = imageDataAllocator;\n\n    private constructor () { }  // singleton\n\n    /**\n     * Set the allocator for this class. Use for testing.\n     * @param imageDataAllocator functon which instiate the canvas's imagedata\n     */\n    static SetImageDataAllocator( imageDataAllocator  : ImageDataAllocator  ) : void {\n        ColourModels.allocator=imageDataAllocator\n    }\n\n    /**\n     * Generate a canvas from HSV components\n     * @param hImg hue image. Float image, with values from 0 to 360\n     * @param sImg saturation image. Float image with values from 0 to 1\n     * @param vImg value image. Float image with values from 0 to 1\n     */\n    static fromHSV( hImg : ImageFloat32, sImg : ImageFloat32, vImg : ImageFloat32) : ImageData {\n        let width = hImg.width\n        let height= hImg.height\n        let data = new Uint8ClampedArray( width * height * 4 );\n        let hPixels = hImg.imagePixels\n        let sPixels = sImg.imagePixels\n        let vPixels = vImg.imagePixels\n        let ptr =0;\n        for( let p=0; p<width*height; p++){\n            let h = hPixels[p]\n            let s = sPixels[p]\n            let v = vPixels[p]\n            let rgb = this.Hsv2Rgb(h,s,v)\n            data[ptr++] = rgb.r * 255\n            data[ptr++] = rgb.g * 255\n            data[ptr++] = rgb.b * 255\n            data[ptr++] = 255; // alpha \n        }\n        return ColourModels.allocator(data, width, height);\n    }\n\n    /**\n     *  decompose the current canvas in hue, saturation and value. \n     * @param image inpout canvas\n     * @returns hue : from 0 to 360, sat from 0 to 1, val from 0 to 1\n     */\n    static toHSV( image : ImageData ) : { hue : ImageFloat32, sat: ImageFloat32, val : ImageFloat32 } {\n        let width = image.width\n        let height= image.height\n        let hImg= ImageFactory.Float32(width,height)\n        let sImg= ImageFactory.Float32(width,height) \n        let vImg= ImageFactory.Float32(width,height) \n        let hPixels= hImg.imagePixels\n        let sPixels= sImg.imagePixels\n        let vPixels= vImg.imagePixels\n        let data= image.data\n        let ptr =0\n        for(let p=0; p<width*height;p++ ){\n            let r=data[ptr++];\n            let g=data[ptr++];\n            let b=data[ptr++];\n            let a=data[ptr++]; \n            let hsv = this.Rgb2Hsv(r/255, g/255, b/255);\n            hPixels[p]=hsv.h;\n            sPixels[p]=hsv.s;\n            vPixels[p]=hsv.v;\n        }\n        return { hue: hImg, sat : sImg, val : vImg }    \n    }\n    \n\n    /**\n     * convert the values in HSV coordinates\n     * @param r red value in   [0,1.0]\n     * @param g green value in [0,1.0]\n     * @param b blue value in [0,1.0]\n     * @returns h in [0,360], s in [0,1] and v in [0,1]\n     */\n     private static Rgb2Hsv( r: number, g : number, b: number  ) : { h: number, s: number, v: number } {\n        // talen from https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both\n        let out = { h: 0, v:0, s: 0}\n        let min = Math.min(r,g,b)\n        let max = Math.max(r,g,b)\n        let delta = max-min\n        out.v = max;\n        if ( delta < 0.00001) {\n            out.h =0\n            out.s =0\n        } else {\n            out.s = delta/max\n            if( r === max ) out.h = 0 + (g-b)/delta\n            if( g === max ) out.h = 2 + (b-r)/delta\n            if( b === max ) out.h = 4 + (r-g)/delta\n        }\n\n        out.h *= 60 // in degrees\n        if( out.h < 0 ) out.h += 360\n\n        return out\n    }\n\n    /**\n     * \n     * @param h [0,360]\n     * @param s [0,1]\n     * @param v [0,1]\n     * @returns r [0,255] g [0,255] and b [0,255]\n     */\n    private static Hsv2Rgb(h:number, s:number, v:number) : {r:number, g:number, b:number} {\n        // from https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both\n        let out = { r:v, g:v, b:v}\n        if( s > 0 ){\n            let hh = h / 60\n            let region = Math.floor(hh)\n            let reminder = hh - region\n            let p = v * ( 1- s )\n            let q = v * ( 1- (s * reminder))\n            let t = v * ( 1- (s * (1 - reminder)))\n            switch( region ){\n                case 0: \n                    out.r = v\n                    out.g = t\n                    out.b = p\n                    break;\n                case 1:\n                    out.r = q\n                    out.g = v\n                    out.b = p\n                    break;\n                case 2:\n                    out.r = p\n                    out.g = v\n                    out.b = t\n                    break\n                case 3:\n                    out.r = p\n                    out.g = q\n                    out.b = v\n                    break\n                case 4:\n                    out.r = t\n                    out.g = p\n                    out.b = v\n                    break\n                default:\n                    out.r = v\n                    out.g = p\n                    out.b = q\n            }\n        }\n\n        return out\n    }\n\n    /**\n     * generate a canvas from a LAB image : components using Observer= 2°, Illuminant= D65\n     * see https://en.wikipedia.org/wiki/CIELAB_color_space\n     * @param lImg light image\n     * @param aImg \n     * @param bImg \n     * @returns \n     */\n    static fromLab( lImg : ImageFloat32, aImg : ImageFloat32, bImg : ImageFloat32) : ImageData {\n        let width = lImg.width\n        let height= lImg.height\n        let data = new Uint8ClampedArray( width * height * 4 );\n        let lPixels = lImg.imagePixels\n        let aPixels = aImg.imagePixels\n        let bPixels = bImg.imagePixels\n        let ptr =0;\n        for( let p=0; p<width*height; p++){\n            let l = lPixels[p]\n            let a = aPixels[p]\n            let b = bPixels[p]\n            let rgb = this.Lab2Rgb(l,a,b)\n            data[ptr++] = rgb.r * 255;\n            data[ptr++] = rgb.g * 255;\n            data[ptr++] = rgb.b * 255;\n            data[ptr++] = 255; // alpha\n        }\n        return ColourModels.allocator(data, width, height);\n    }\n\n     /**\n     * convert the input canvas, assumed to be un RGB space, in to LAB\n     * components using Observer= 2°, Illuminant= D65\n     * @param image input image\n     */\n        static toLab(image : ImageData ) : { l : ImageFloat32, a : ImageFloat32, b :ImageFloat32 } {\n        let width = image.width\n        let height= image.height\n        let lImg= ImageFactory.Float32(width,height)\n        let aImg= ImageFactory.Float32(width,height) \n        let bImg= ImageFactory.Float32(width,height) \n        let lPixels= lImg.imagePixels\n        let aPixels= aImg.imagePixels\n        let bPixels= bImg.imagePixels\n        let data= image.data\n        let ptr =0\n        for(let p=0; p<width*height;p++ ){\n            let r=data[ptr++];\n            let g=data[ptr++];\n            let b=data[ptr++];\n            let a=data[ptr++];\n            let lab = this.Rgb2Lab(r/255, g/255, b/255);\n            lPixels[p]=lab.l;\n            aPixels[p]=lab.a;\n            bPixels[p]=lab.b;\n        }\n        return { l: lImg, a: aImg, b: bImg}    \n    }\n\n    // Taken from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n    // which in turns is taken from the heavily referenced web site :\n    // https://www.easyrgb.com/en/math.php\n    static Rgb2Lab(r: number, g: number, b: number) : { l: number, a:number, b:number } {\n  \n        r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n        g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n        b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n    \n        let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;\n        let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;\n        let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;\n    \n        x = (x > 0.008856) ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;\n        y = (y > 0.008856) ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;\n        z = (z > 0.008856) ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;\n    \n        return { l : (116 * y) - 16, a: 500 * (x - y), b: 200 * (y - z) }\n    }\n\n    static Lab2Rgb(l: number, a: number, b: number) {\n        let y = (l + 16) / 116\n        let x = a / 500 + y\n        let z = y - b / 200\n  \n        x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16/116) / 7.787);\n        y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16/116) / 7.787);\n        z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16/116) / 7.787);\n\n        let rgb = {\n            r : x *  3.2406 + y * -1.5372 + z * -0.4986,\n            g : x * -0.9689 + y *  1.8758 + z *  0.0415,\n            b : x *  0.0557 + y * -0.2040 + z *  1.0570\n        }\n    \n        rgb.r = (rgb.r > 0.0031308) ? (1.055 * Math.pow(rgb.r, 1/2.4) - 0.055) : 12.92 * rgb.r;\n        rgb.g = (rgb.g > 0.0031308) ? (1.055 * Math.pow(rgb.g, 1/2.4) - 0.055) : 12.92 * rgb.g;\n        rgb.b = (rgb.b > 0.0031308) ? (1.055 * Math.pow(rgb.b, 1/2.4) - 0.055) : 12.92 * rgb.b;\n\n        rgb.r = Math.max(0, Math.min(1,rgb.r))\n        rgb.g = Math.max(0, Math.min(1,rgb.g))\n        rgb.b = Math.max(0, Math.min(1,rgb.b))\n\n        return rgb\n    }\n\n    /**\n     *  Generate the canvas's channels (red, green, blue and alpha) in separate images.\n     * @param canvas \n     */\n        static toRGB( canvas : ImageData ) : { r : ImageUint8, g : ImageUint8, b : ImageUint8 } {\n            let width = canvas.width;\n            let height= canvas.height;\n            let imgR= ImageFactory.Uint8(width,height);\n            let imgG= ImageFactory.Uint8(width,height);\n            let imgB= ImageFactory.Uint8(width,height);\n            let nPixels = width*height;\n            let i =0;\n            let cPixels = canvas.data;\n            let rPixels = imgR.imagePixels;\n            let gPixels = imgG.imagePixels;\n            let bPixels = imgB.imagePixels;\n        \n            for( let p=0; p<nPixels; p++){\n                rPixels[p]=cPixels[i++];\n                gPixels[p]=cPixels[i++];\n                bPixels[p]=cPixels[i++];\n                i++; // skip alpha\n            }\n\n            return { r: imgR, g: imgG, b :imgB }\n        }\n    \n        /**\n         * generate a ImageData object using the images provided as channels.\n         * @param imgR \n         * @param imgG \n         * @param imgB \n         */\n        static fromRGB( imgR : ImageUint8, imgG : ImageUint8, imgB : ImageUint8 ): ImageData {\n            let width = imgR.width;\n            let height= imgR.height;\n            let nPixels = width*height;\n            let i =0;\n            let cPixels = new Uint8ClampedArray( width * height * 4 );\n            let rPixels = imgR.imagePixels;\n            let gPixels = imgG.imagePixels;\n            let bPixels = imgB.imagePixels;\n        \n            for( let p=0; p<nPixels; p++){\n                cPixels[i++] = rPixels[p];\n                cPixels[i++] = gPixels[p];\n                cPixels[i++] = bPixels[p];\n                cPixels[i++] = 255;\n            }\n    \n            return ColourModels.allocator(cPixels,width,height)\n        }\n}","import BoundingBox from './BoundingBox';\nimport IImage, {Bbox, Colour, Point} from './Types'\n\nexport function isMask( obj : any ) : obj is Mask {\n    return obj.constructor.name === \"Mask\"\n}\n\n\n/**\n * 2D binary mask\n */\nexport default class Mask implements IImage<boolean> {\n    private pixels : boolean [];\n    private w : number ;\n\n    /**\n     * Initialize an empty mask, with all values to false.\n     * @param width  \n     * @param height \n     */\n    constructor( width : number, height : number ){\n        this.w = width;\n        this.pixels= new Array<boolean>(width*height).fill(false);\n    }\n\n    /**\n     * clone the incoming mask\n     * @param srcMask \n     */\n    static Clone( srcMask : Mask ) : Mask {\n        const mask  = new Mask(srcMask.width, srcMask.height);\n        mask.pixels = [...srcMask.pixels];\n        return mask;\n    }\n\n    /**\n     * get the unidimensional pixel array, row major\n     */\n    get imagePixels() : boolean [] {\n        return this.pixels;\n    }\n\n    /**\n     * image width\n     */\n    get width() : number {\n        return this.w;\n    }\n\n    /**\n     * image height\n     */\n    get height():number {\n        return this.pixels.length/this.w;\n    }\n\n    /**\n     * area (number of pixels set to true)\n     */\n    get area() : number {\n        return this.pixels.reduce((s,v)=>s+(v?1:0), 0)\n    }\n\n    /**\n     * get a value in the mask\n     * @param x \n     * @param y \n     * @returns \n     */\n    get( x: number, y: number ){\n        this.checkSize(x,y);\n        return this.pixels[this.w*y+x];\n    }\n\n    /**\n     * Set a value in the mask\n     * @param x \n     * @param y \n     * @param v value\n     */\n    set( x: number, y:number, v: boolean ){\n        this.checkSize(x,y);\n        this.pixels[this.w*y+x]=v;\n    }\n\n    /*\n    * overwrite toString in order to provide information when the image is printed\n    */\n    toString() : string {\n        return `Mask ${this.width}x${this.height}`\n        }\n\n    /**\n     * And the mask with the incoming mask in place.\n     * @param srcMask \n     */\n    And( srcMask : Mask ) {\n        if( srcMask.pixels.length !== this.pixels.length ) throw new Error(`Wrong Mask sizes : ${srcMask.pixels.length} vs ${this.pixels.length}`);\n        this.pixels = this.pixels.map((v,i)=>v&&srcMask.pixels[i]);\n    }\n\n\n    /**\n     * Or the mask with the incoming mask in place\n     * @param srcMask \n     */\n    Or( srcMask : Mask ) {\n        if( srcMask.pixels.length !== this.pixels.length ) throw new Error(`Wrong Mask sizes : ${srcMask.pixels.length} vs ${this.pixels.length}`);\n        this.pixels = this.pixels.map((v,i)=>v||srcMask.pixels[i]);\n    }\n\n    /**\n     * subtract the incoming mask, in place.\n     * @param srcMask \n     */\n    Minus( srcMask : Mask ) {\n        if( srcMask.pixels.length !== this.pixels.length ) throw new Error(`Wrong Mask sizes : ${srcMask.pixels.length} vs ${this.pixels.length}`);\n        srcMask.pixels.forEach((v,i)=> v ? this.pixels[i]=false : null); // in place, otherwise the fill function will take too long.\n    }\n\n    /**\n     * Not the mask in place.\n     */\n    Not() {\n        this.pixels = this.pixels.map((v)=>!v); \n    }\n\n    /**\n     * invoke for every pixel in the image the function provided.\n     * @param func \n     */\n    foreachPixel (func : (x:number, y:number, v: boolean )=> void) : void  {\n        this.pixels.forEach((val, i)=>{\n            const x = i % this.w;\n            const y = i / this.w|0;\n            func(x,y,val);\n        })\n    }\n\n\n    /**\n     * Fill operation : retun a mask with the connected compnent (9 neighbourd) to the seed point.\n     * @param xSeed x coordinate seed point. It shall be inside the image\n     * @param ySeed y coordinate seed point. It shall be inside the image.\n     * @returns \n     */\n\n    Fill(xSeed : number, ySeed : number ) : Mask {\n        const width = this.width;\n        const height= this.height;\n        if( xSeed <0 || xSeed >= width || ySeed <0 || ySeed >=height  ) throw new Error(`invalid seed point ${xSeed},${ySeed}`);\n        const inpPixels = this.pixels;\n        const outMask   = new Mask(width,height);\n        const outPixels = outMask.imagePixels;\n        const NeigbourdPoints : Point [] = [ { x:-1, y:0 },\n                                             { x:1, y:0 },\n                                             { x:0, y:1 },\n                                             { x:0, y:-1 },\n                                             { x:1, y:1 },\n                                             { x:-1, y:1 },\n                                             { x:1, y:-1 },\n                                             { x:-1, y:-1 }\n        ]\n\n        const stack : Point[] = [ {x:xSeed, y:ySeed}]\n        outPixels[ySeed*width+xSeed] = true;\n\n        while( stack.length > 0 ){\n\n            const pt = stack.shift()!\n\n            for( const p of NeigbourdPoints ){\n                const x = pt.x + p.x;\n                const y = pt.y + p.y;\n                if( x>=0 && x<width && y>=0 && y<height ){\n                    const offset = y*width+x;\n                    if( inpPixels[offset] && !outPixels[offset] ){\n                        outPixels[offset]= true;\n                        stack.push({x,y})\n                    }\n                }\n            }\n        }\n\n        return outMask;\n    }\n\n    /**\n     * applies a dilation with a squared mask, 2*halfSize+1 x 2*halfSize+1\n     * @param halfSize mask half size\n     * @returns \n     */\n    Dilate(halfSize:number ) : Mask {\n        const width = this.width;\n        const height= this.height;\n        const inpPixels = this.pixels;\n        const outMask   = Mask.Clone(this);\n        const outPixels = outMask.imagePixels;\n\n        outMask.foreachPixel((x,y,v)=>{\n            if( !v && x>=halfSize && x<width-halfSize && y>=halfSize && y<height-halfSize  ){\n                let val = false;\n                const len = 2*halfSize+1;\n                for( let yk = y-halfSize; yk<=y+halfSize; yk++ ){\n                    let offset  = yk * width+x-halfSize;\n                    for( let off=offset; off<len+offset; off++) {\n                        val ||= inpPixels[off];\n                    }\n                    if( val ) break;\n                }\n                outPixels[y*width+x]= val;\n            }\n        })\n\n        return outMask;\n    }\n\n    /**\n     * overlays the current mask on the image provided.\n     * @param imgData \n     * @param color  \n     */\n    Overlay(imgData : ImageData, {r,g,b,a =255 } : Colour ) : void {\n        if( this.width !== imgData.width || this.height !== imgData.height ) throw new Error(`Invalid data : Mask size ${this.width}x${this.height} and image data ${imgData.width}x${imgData.height}`)\n        const data = imgData.data;\n        let ptr = 0;\n        const alpha = a/255;\n        r *= alpha;\n        b *= alpha;\n        g *= alpha;\n        const weight = 1-alpha;\n\n        this.pixels.forEach((v)=>{\n            if( v ){\n                let p = ptr;\n                const red  = data[ptr++] * weight + r;\n                const green= data[ptr++] * weight + g;\n                const blue = data[ptr++] * weight + b;\n                const alpha= data[ptr++] * weight + a;\n                data[p++] = red;\n                data[p++] = green;\n                data[p++] = blue;\n                data[p++] = alpha;\n            } else {\n                ptr += 4;\n            } \n        })\n    }\n\n    /**\n     * return the num largest component of the mask.\n     * @param num number of components to return.\n     * @returns list of connected component, sorted by size.\n     */\n    Components ( num : number ) : Mask [] {\n        const list : {mask:Mask, area:number }[] = [];\n\n        this.foreachPixel((x,y,v)=>{\n            if( v ){\n                const mask = this.Fill(x,y);\n                const area = mask.area;\n                list.push({mask,area});\n                list.sort((a,b)=>b.area-a.area);\n                list.length = Math.min(list.length,num); // trucate the list as necessary.\n                this.Minus(mask);\n            }\n        })\n\n        return list.map(v=>v.mask);\n    }\n\n    /**\n     * dermine the boundaies of the bask\n     */\n    Boundaries() :  Bbox {\n        let xMin = this.width;\n        let yMin = this.height;\n        let xMax = 0;\n        let yMax  =0;\n\n        this.foreachPixel((x,y,v)=>{\n            if( v ){\n                xMin = x < xMin ? x : xMin;\n                yMin = y < yMin ? y : yMin;\n                xMax = x > xMax ? x : xMax;\n                yMax = y > yMax ? y : yMax;\n            }\n        })\n\n        return BoundingBox.FromValues(xMin, yMin, xMax+1, yMax+1);\n    }\n\n    private checkSize( x : number, y: number ){\n        if( x < 0 || x > this.w || y <0 || y > this.height ) throw new Error(`Wrong coordinate for mask (${x},${y}) and mask size ${this.w}x${this.height}`);\n    }\n\n}","import ColourModels from \"../../common/imgLib/ColourModels\";\nimport Mask from \"../../common/imgLib/Mask\";\nimport { Bbox, Colour } from \"../../common/imgLib/Types\";\n\n/**\n * This class perform the segmentation of the leaf, given the image and thresholds\n */\nexport default class LeafSeg {\n\n    private constructor( ) { } // singleton\n\n    /**\n     * Perform the identification of the leaf(s) in the input image\n     * @param imgData  input image\n     * @param hueThr  hue threshold [0,360]\n     * @param satThr saturation threshold [0,1]\n     * @param nLeafs number of leafs 1 or 2\n     * @returns areas : array with the areas measured, bboxs : bounding box for each leaf measured.\n     */\n    static Process(imgData : ImageData, hueThr : number, satThr : number, nLeafs : number ) :  { areas : number[], bboxs : Bbox[] }  {\n        let areas : number [] = [];\n        let bboxs : Bbox[]    = [];\n\n        const {hue,sat} = ColourModels.toHSV(imgData);\n        const rMask = new Mask(imgData.width, imgData.height);\n        const mPixels = rMask.imagePixels;\n        const hPixels = hue.imagePixels;\n        const sPixels = sat.imagePixels;\n\n        // background mask\n        hueThr *= 360/255;\n        satThr *= 1/255;\n        hPixels.forEach((v,i)=>mPixels[i]= v > hueThr || sPixels[i] < satThr); \n\n        // fill holes\n        const bMask = rMask.Fill(1,1);\n        const dMask = bMask;\n\n        // foregound mask\n        dMask.Not();\n\n        // extract components\n        const leafs = dMask.Components(nLeafs);\n\n        // overlay\n        const colours : Colour [] = [{r:255,g:0,b:0},{r:255,g:255,b:0}];\n\n        leafs.forEach((m, i)=>{\n            const col  = colours[i%colours.length];\n            const area = m.area;\n            const bbox = m.Boundaries();\n            areas.push(area);\n            bboxs.push(bbox);\n            const dil  = m.Dilate(1);\n            dil.Minus(m); // this is the outline.\n            dil.Overlay(imgData, col);  \n        })\n\n        return { areas, bboxs};\n    }\n\n}","// the next line declare that we are in the web workers\n\n/// <reference lib=\"webworker\" />\n\n//\n// Using the model directly supported by Webpack 5 https://webpack.js.org/guides/web-workers/\n//\n\nimport { imageSize } from \"../../app/const\";\nimport ImageLoader from \"../foreground/ImageLoader\";\nimport LeafCrop from \"./LeafCrop\";\nimport LeafSeg from \"./LeafSeg\";\n\nexport interface QueryMessage {\n    file    : FileSystemFileHandle, \n    nDishes : number,\n    name    : string,\n    hueThr  : number, \n    satThr  : number, \n    nLeafs  : number \n}\nexport interface AnswerMessage {\n    imgData : ImageData, \n    areas   : number[]\n}\n\n/* eslint-disable-next-line no-restricted-globals */\nself.onmessage=async (ev:MessageEvent<QueryMessage>)=> {\n    const {file, name, nDishes, hueThr, satThr, nLeafs } = ev.data\n    const imgLoader = new ImageLoader([file], nDishes, imageSize);\n    const imgIndex  = imgLoader.List.indexOf(name);\n    const {imgData, scale} = await imgLoader.getImage(imgIndex)\n    const {areas, bboxs } = LeafSeg.Process(imgData!, hueThr, satThr, nLeafs);\n    const result = LeafCrop.Process(areas, bboxs, imgData!, scale);\n    sendMessage(result);\n}\n\nfunction sendMessage( msg : AnswerMessage ) {\n    /* eslint-disable-next-line no-restricted-globals */\n    self.postMessage(msg);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [271], function() { return __webpack_require__(9718); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"e722dad0\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/LeafSize/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t718: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkleafsize\"] = self[\"webpackChunkleafsize\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(271).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","noExtension","filename","index","lastIndexOf","res","substring","ImageLoader","files","numDishes","targetSize","imageFileLoader","getImageFromFile","tiles","cacheImage","cacheFile","this","Error","map","file","quadrant","name","forEach","push","f","find","v","Set","size","scale","imgData","length","tile","getImageFromCache","img","imgWidth","width","imgHeight","height","xTopLft","yTopLft","xBtmRgt","yBtmRgt","xMid","yMid","srcWidth","srcHeight","srcDiag","Math","sqrt","min","dstWidth","dstHeight","document","canvas","OffscreenCanvas","createElement","ctx","getContext","drawImage","getImageData","close","handle","getFile","arrayBuffer","data","blob","Blob","createImageBitmap","imageDataAllocator","ImageData","BoundingBox","allocator","pt1","pt2","FromValues","x","y","x1","y1","x2","y2","xmin","xmax","max","ymin","ulc","bbox","boxes","box","Empty","ymax","b","dx","dy","imageData","imageBox","int","Intersect","IsEmpty","dst","Uint8ClampedArray","src","dstPt","srcPt","LeafCrop","areas","bboxs","Merge","leafData","leafAreas","wDilation","hDilation","dBox","Dilate","CropImage","ImageFactory","ImageBase","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Float32Array","type","Uint8","Uint16","Float32","elementSize","constructor","buffer","pixels","nPixels","ArrayBuffer","Array","from","e","i","replace","imageType","checkBoundary","func","val","reduce","idx","value","slope","intercept","convertTo","dstImage","Image","dstPixels","imagePixels","ColourModels","hImg","sImg","vImg","hPixels","sPixels","vPixels","ptr","p","h","s","rgb","Hsv2Rgb","r","g","image","hsv","Rgb2Hsv","hue","sat","out","delta","hh","region","floor","reminder","q","t","lImg","aImg","bImg","lPixels","aPixels","bPixels","l","a","Lab2Rgb","lab","Rgb2Lab","pow","z","imgR","imgG","imgB","cPixels","rPixels","gPixels","Mask","w","fill","checkSize","srcMask","xSeed","ySeed","inpPixels","outMask","outPixels","NeigbourdPoints","stack","pt","shift","offset","halfSize","Clone","foreachPixel","len","yk","off","alpha","weight","red","green","blue","num","list","mask","Fill","area","sort","Minus","xMin","yMin","xMax","yMax","LeafSeg","hueThr","satThr","nLeafs","toHSV","rMask","mPixels","dMask","Not","leafs","Components","colours","m","col","Boundaries","dil","Overlay","self","onmessage","ev","nDishes","imgLoader","imgIndex","List","indexOf","getImage","Process","result","msg","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","splice","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}